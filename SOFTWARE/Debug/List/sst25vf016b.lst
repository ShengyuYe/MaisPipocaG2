###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      06/Jul/2017  16:40:11 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Drivers\sst25vf016b\sst25vf016b.c         #
#    Command line =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Drivers\sst25vf016b\sst25vf016b.c -lC     #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\ -lA                           #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\ -o                            #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\Obj\ --no_cse --no_unroll           #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -Ol                                               #
#    List file    =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\sst25vf016b.lst                #
#    Object file  =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\Obj\sst25vf016b.o                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPipocaG2\SOFTWARE\Drivers\sst25vf016b\sst25vf016b.c
      1          /*__________________________________________________________________________________
      2          |	Quark Tecnologia Eletrônica Embarcada
      3          |       
      4          |       Itapema - SC
      5          |       www.quarktee.com.br
      6          | __________________________________________________________________________________
      7          |
      8          |       This source code was developed by Quark  and cannot be copied, in part 
      9          |       or in whole, or used, except when legally licensed by Quark 
     10          |       or its distributors.
     11          |
     12          |       Este código é propriedade da Quark  e não pode ser copiado, em parte 
     13          |       ou em todo, ou utilizado, exceto quando for legalmente licenciado pela 
     14          |       Quark  ou por um de seus distribuidores.
     15          | __________________________________________________________________________________
     16          |
     17          |       Arquivo            :  SST25VFXX.c
     18          |       Descrição          :  Driver para acesso à memoria
     19          |                             SST25
     20          | 
     21          |       Autor              :  Marcos Aquino
     22          |       Data criação       :  27/04/2012
     23          |
     24          |       Revisões           :  1.0.0.0
     25          |
     26          |
     27          | __________________________________________________________________________________
     28          */
     29          
     30          /********************************************************************************
     31          *   Includes
     32          ********************************************************************************/
     33          #include <nxp/iolpc1768.h>

   \                                 In section .noinit, at 0x2009c018
   \   __absolute union <unnamed> volatile _A_FIO0SET
   \                     _A_FIO0SET:
   \   00000000                      DS8 4

   \                                 In section .noinit, at 0x2009c01c
   \   __absolute union <unnamed> volatile _A_FIO0CLR
   \                     _A_FIO0CLR:
   \   00000000                      DS8 4
     34          #include "SST25VF016B.h"
     35          #include "SPI_WRAPPER.H"
     36          
     37          /********************************************************************************
     38          *   Definições
     39          ********************************************************************************/
     40          #define SST_READ                        0x03
     41          #define SST_HIGH_SPEED_READ             0x0B
     42          #define SST_4KB_ERASE                   0x20
     43          #define SST_32KB_ERASE                  0x52
     44          #define SST_64KB_ERASE                  0xD8
     45          #define SST_CHIP_ERASE                  0x60
     46          #define SST_BYTE_PROGRAM                0x02
     47          #define SST_AAI                         0xAD
     48          #define SST_RDSR                        0x05
     49          #define SST_EWSR                        0x50
     50          #define SST_WRITE_STATUS                0x01
     51          #define SST_WRITE_ENABLE                0x06
     52          #define SST_WRITE_DISABLE               0x04
     53          #define SST_READ_ID                     0x90
     54          #define SST_JEDEC_ID                    0x9F
     55          #define SST_EBST                        0x70
     56          #define SST_DBSY                        0x80
     57          
     58          /********************************************************************************
     59          *   Funções
     60          ********************************************************************************/
     61          void SST_busyWait(void);
     62          
     63          /********************************************************************************
     64          *   Implementação
     65          ********************************************************************************/
     66          
     67          /********************************************************************************
     68          *   Descrição     :   Inicialização do driver
     69          *   Parametros    :   nenhum
     70          *   Retorno       :   nenhum
     71          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     72          void SST25VF_init(unsigned long int busClk){
     73            
     74            UNSEL_CS_01;  
   \                     SST25VF_init:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x2009c018
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x2009c018
   \   0000000E   0x6008             STR      R0,[R1, #+0]
     75            UNSEL_CS_02;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x2009c018
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x2009c018
   \   0000001E   0x6008             STR      R0,[R1, #+0]
     76          }
   \   00000020   0x4770             BX       LR               ;; return
   \   00000022                      REQUIRE _A_FIO0SET
     77          /********************************************************************************
     78          *   Descrição     :   Faz a leitura do registrador de status da memória
     79          *   Parametros    :   (SST_status*) referência para o status
     80          *   Retorno       :   nenhum
     81          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     82          void SST25VF_readStatus(SST_status* status){
   \                     SST25VF_readStatus:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
     83            unsigned char buffer;
     84            
     85            SEL_CS_01;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x2009c01c
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x2009c01c
   \   00000014   0x6008             STR      R0,[R1, #+0]
     86            
     87            buffer = SST_RDSR;  
   \   00000016   0x2005             MOVS     R0,#+5
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
     88            
     89            SPI_sendBytes(&buffer,1);
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0xA800             ADD      R0,SP,#+0
   \   00000020   0x.... 0x....      BL       SPI_sendBytes
     90            SPI_getBytes((unsigned char*)status,1);
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       SPI_getBytes
     91            
     92            UNSEL_CS_01;      
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x2009c018
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x2009c018
   \   0000003A   0x6008             STR      R0,[R1, #+0]
     93          }
   \   0000003C   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   \   0000003E                      REQUIRE _A_FIO0CLR
   \   0000003E                      REQUIRE _A_FIO0SET
     94          /********************************************************************************
     95          *   Descrição     :   Aguarda o sinal de busy ficar zerado
     96          *   Parametors    :   nenhum
     97          *   Retorno       :   nenhum
     98          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     99          void SST_busyWait(void){
   \                     SST_busyWait:
   \   00000000   0xB580             PUSH     {R7,LR}
    100            
    101            SST_status status;      
    102            do SST25VF_readStatus(&status);            
   \                     ??SST_busyWait_0:
   \   00000002   0xA800             ADD      R0,SP,#+0
   \   00000004   0x.... 0x....      BL       SST25VF_readStatus
    103            while(status.busy);   
   \   00000008   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000000C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD1F6             BNE.N    ??SST_busyWait_0
    104          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    105          /********************************************************************************
    106          *   Descrição     :   Faz a escrita no registrador de estado
    107          *   Parametros    :   (SST_status*) valor para ser escrito no status
    108          *   Retorno       :   nenhum
    109          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    110          unsigned char SST25VF_writeStatus(SST_status *status){
   \                     SST25VF_writeStatus:
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    111            unsigned char buffer[2];
    112            SST_status tmp;
    113            
    114            SEL_CS_01;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x2009c01c
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x2009c01c
   \   00000012   0x6008             STR      R0,[R1, #+0]
    115            buffer[0] = SST_EWSR;
   \   00000014   0x2050             MOVS     R0,#+80
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
    116            SPI_sendBytes(buffer,1);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0xA800             ADD      R0,SP,#+0
   \   0000001E   0x.... 0x....      BL       SPI_sendBytes
    117            UNSEL_CS_01;
   \   00000022   0x....             LDR.N    R0,??DataTable12  ;; 0x2009c018
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000002A   0x....             LDR.N    R1,??DataTable12  ;; 0x2009c018
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    118            
    119            buffer[0] = SST_WRITE_STATUS;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF88D 0x0000      STRB     R0,[SP, #+0]
    120            buffer[1] = *(unsigned char*)status;
   \   00000034   0x7820             LDRB     R0,[R4, #+0]
   \   00000036   0xF88D 0x0001      STRB     R0,[SP, #+1]
    121            
    122            SEL_CS_01;
   \   0000003A   0x....             LDR.N    R0,??DataTable12_1  ;; 0x2009c01c
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000042   0x....             LDR.N    R1,??DataTable12_1  ;; 0x2009c01c
   \   00000044   0x6008             STR      R0,[R1, #+0]
    123            SPI_sendBytes(buffer,2);    
   \   00000046   0x2102             MOVS     R1,#+2
   \   00000048   0xA800             ADD      R0,SP,#+0
   \   0000004A   0x.... 0x....      BL       SPI_sendBytes
    124            UNSEL_CS_01;          
   \   0000004E   0x....             LDR.N    R0,??DataTable12  ;; 0x2009c018
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000056   0x....             LDR.N    R1,??DataTable12  ;; 0x2009c018
   \   00000058   0x6008             STR      R0,[R1, #+0]
    125            
    126            SST25VF_readStatus(&tmp);
   \   0000005A   0xA801             ADD      R0,SP,#+4
   \   0000005C   0x.... 0x....      BL       SST25VF_readStatus
    127            
    128            if(*(unsigned char*)&tmp == *(unsigned char*)status)
   \   00000060   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000064   0x7821             LDRB     R1,[R4, #+0]
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xD101             BNE.N    ??SST25VF_writeStatus_0
    129              return 0xFF;
   \   0000006A   0x20FF             MOVS     R0,#+255
   \   0000006C   0xE000             B.N      ??SST25VF_writeStatus_1
    130            
    131            return 0x00;
   \                     ??SST25VF_writeStatus_0:
   \   0000006E   0x2000             MOVS     R0,#+0
   \                     ??SST25VF_writeStatus_1:
   \   00000070   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   \   00000072                      REQUIRE _A_FIO0CLR
   \   00000072                      REQUIRE _A_FIO0SET
    132          }     
    133          /********************************************************************************
    134          *   Descrição     :   Lê o ID da memória
    135          *   Parametros    :   nenhum
    136          *   Retorno       :   (unsigned short int) valor lido da memória
    137          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    138          unsigned short int SST_readID(void){
   \                     SST_readID:
   \   00000000   0xB580             PUSH     {R7,LR}
    139            unsigned char buffer[4];
    140            
    141            SEL_CS_01;
   \   00000002   0x....             LDR.N    R0,??DataTable12_1  ;; 0x2009c01c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000000A   0x....             LDR.N    R1,??DataTable12_1  ;; 0x2009c01c
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    142            
    143            buffer[0] = SST_READ_ID;
   \   0000000E   0x2090             MOVS     R0,#+144
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    144            buffer[1] = 0x00;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF88D 0x0001      STRB     R0,[SP, #+1]
    145            buffer[2] = 0x00;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    146            buffer[3] = 0x00;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF88D 0x0003      STRB     R0,[SP, #+3]
    147            
    148            SPI_sendBytes(buffer,4);
   \   00000026   0x2104             MOVS     R1,#+4
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       SPI_sendBytes
    149            SPI_getBytes(buffer,4);
   \   0000002E   0x2104             MOVS     R1,#+4
   \   00000030   0xA800             ADD      R0,SP,#+0
   \   00000032   0x.... 0x....      BL       SPI_getBytes
    150            
    151            UNSEL_CS_01;  
   \   00000036   0x....             LDR.N    R0,??DataTable12  ;; 0x2009c018
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000003E   0x....             LDR.N    R1,??DataTable12  ;; 0x2009c018
   \   00000040   0x6008             STR      R0,[R1, #+0]
    152             
    153            return (unsigned short int)buffer[0]<<8 | buffer[1];
   \   00000042   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000046   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   0000004A   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000004E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000050   0xBD02             POP      {R1,PC}          ;; return
   \   00000052                      REQUIRE _A_FIO0CLR
   \   00000052                      REQUIRE _A_FIO0SET
    154          }
    155          /********************************************************************************
    156          *   Descrição     :   Habilita a escrita na memoria
    157          *   Parametros    :   nenhum
    158          *   Retorno       :   nenhum
    159          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    160          void SST_writeEnable(void){
   \                     SST_writeEnable:
   \   00000000   0xB580             PUSH     {R7,LR}
    161            unsigned char buffer;
    162            
    163            SEL_CS_01;
   \   00000002   0x....             LDR.N    R0,??DataTable12_1  ;; 0x2009c01c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000000A   0x....             LDR.N    R1,??DataTable12_1  ;; 0x2009c01c
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    164            buffer = SST_WRITE_ENABLE;
   \   0000000E   0x2006             MOVS     R0,#+6
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    165            SPI_sendBytes(&buffer,1);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xA800             ADD      R0,SP,#+0
   \   00000018   0x.... 0x....      BL       SPI_sendBytes
    166            UNSEL_CS_01;     
   \   0000001C   0x....             LDR.N    R0,??DataTable12  ;; 0x2009c018
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000024   0x....             LDR.N    R1,??DataTable12  ;; 0x2009c018
   \   00000026   0x6008             STR      R0,[R1, #+0]
    167          }
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
   \   0000002A                      REQUIRE _A_FIO0CLR
   \   0000002A                      REQUIRE _A_FIO0SET
    168          /********************************************************************************
    169          *   Descrição     :   Desabilita a escrita na memória
    170          *   Parametros    :   nenhum
    171          *   Retorno       :   nenhum
    172          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    173          void SST_writeDisable(void){
   \                     SST_writeDisable:
   \   00000000   0xB580             PUSH     {R7,LR}
    174            unsigned char buffer;
    175          
    176            SEL_CS_01;
   \   00000002   0x....             LDR.N    R0,??DataTable12_1  ;; 0x2009c01c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000000A   0x....             LDR.N    R1,??DataTable12_1  ;; 0x2009c01c
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    177            buffer = SST_WRITE_DISABLE;
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    178            SPI_sendBytes(&buffer,1);  
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xA800             ADD      R0,SP,#+0
   \   00000018   0x.... 0x....      BL       SPI_sendBytes
    179            UNSEL_CS_01;  
   \   0000001C   0x....             LDR.N    R0,??DataTable12  ;; 0x2009c018
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000024   0x....             LDR.N    R1,??DataTable12  ;; 0x2009c018
   \   00000026   0x6008             STR      R0,[R1, #+0]
    180          }
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
   \   0000002A                      REQUIRE _A_FIO0CLR
   \   0000002A                      REQUIRE _A_FIO0SET
    181          /********************************************************************************
    182          *   Descrição     :   Leitura de alta velocidade
    183          *   Parametros    :   (unsigned char*) buffer onde serão alocados os dados lidos
    184          *                     (unsigned short int) número de bytes lidos
    185          *   Retorno       :   nenhum
    186          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    187          void SST_highSpeedRead(unsigned int endereco,unsigned char *buffer,
    188                                 unsigned short int size){
   \                     SST_highSpeedRead:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
    189            unsigned char comandos[5];
    190            
    191            SEL_CS_01;
   \   00000008   0x....             LDR.N    R1,??DataTable12_1  ;; 0x2009c01c
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \   00000010   0x....             LDR.N    R2,??DataTable12_1  ;; 0x2009c01c
   \   00000012   0x6011             STR      R1,[R2, #+0]
    192          
    193            comandos[0] = SST_HIGH_SPEED_READ; 
   \   00000014   0x210B             MOVS     R1,#+11
   \   00000016   0xF88D 0x1000      STRB     R1,[SP, #+0]
    194            comandos[1] = (unsigned char)(endereco>>16);
   \   0000001A   0x0C01             LSRS     R1,R0,#+16
   \   0000001C   0xF88D 0x1001      STRB     R1,[SP, #+1]
    195            comandos[2] = (unsigned char)(endereco>>8);
   \   00000020   0x0A01             LSRS     R1,R0,#+8
   \   00000022   0xF88D 0x1002      STRB     R1,[SP, #+2]
    196            comandos[3] = (unsigned char)endereco;
   \   00000026   0xF88D 0x0003      STRB     R0,[SP, #+3]
    197            comandos[4] = 0x00;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    198            SPI_sendBytes(comandos,5);
   \   00000030   0x2105             MOVS     R1,#+5
   \   00000032   0xA800             ADD      R0,SP,#+0
   \   00000034   0x.... 0x....      BL       SPI_sendBytes
    199            SPI_getBytes(buffer,size);
   \   00000038   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003A   0x0029             MOVS     R1,R5
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       SPI_getBytes
    200                
    201            UNSEL_CS_01;  
   \   00000042   0x....             LDR.N    R0,??DataTable12  ;; 0x2009c018
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000004A   0x....             LDR.N    R1,??DataTable12  ;; 0x2009c018
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    202          }
   \   0000004E   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   \   00000050                      REQUIRE _A_FIO0CLR
   \   00000050                      REQUIRE _A_FIO0SET
    203          /********************************************************************************
    204          *   Descrição   :   Programa um byte na dataflash
    205          *   Parametros  :   (unsigned int) endereco
    206          *                   (unsigned char) valor
    207          *   Retorno     :   nenhum
    208          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    209          void SST_writeByte(unsigned int endereco,unsigned char valor){
   \                     SST_writeByte:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
    210            unsigned char comandos[5];    
    211            
    212            SST_writeEnable(); // Habilita a escrita na memória
   \   00000008   0x.... 0x....      BL       SST_writeEnable
    213            
    214            SEL_CS_01;
   \   0000000C   0x....             LDR.N    R0,??DataTable12_1  ;; 0x2009c01c
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000014   0x....             LDR.N    R1,??DataTable12_1  ;; 0x2009c01c
   \   00000016   0x6008             STR      R0,[R1, #+0]
    215            
    216            comandos[0] = SST_BYTE_PROGRAM;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    217            comandos[1] = (unsigned char)(endereco>>16);
   \   0000001E   0x0C28             LSRS     R0,R5,#+16
   \   00000020   0xF88D 0x0001      STRB     R0,[SP, #+1]
    218            comandos[2] = (unsigned char)(endereco>>8);
   \   00000024   0x0A28             LSRS     R0,R5,#+8
   \   00000026   0xF88D 0x0002      STRB     R0,[SP, #+2]
    219            comandos[3] = (unsigned char) endereco;
   \   0000002A   0xF88D 0x5003      STRB     R5,[SP, #+3]
    220            comandos[4] = valor;
   \   0000002E   0xF88D 0x4004      STRB     R4,[SP, #+4]
    221            SPI_sendBytes(comandos,5);
   \   00000032   0x2105             MOVS     R1,#+5
   \   00000034   0xA800             ADD      R0,SP,#+0
   \   00000036   0x.... 0x....      BL       SPI_sendBytes
    222            
    223            UNSEL_CS_01;      
   \   0000003A   0x....             LDR.N    R0,??DataTable12  ;; 0x2009c018
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000042   0x....             LDR.N    R1,??DataTable12  ;; 0x2009c018
   \   00000044   0x6008             STR      R0,[R1, #+0]
    224            
    225            SST_writeDisable(); // Desabilita a escrita na memória
   \   00000046   0x.... 0x....      BL       SST_writeDisable
    226          }
   \   0000004A   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   \   0000004C                      REQUIRE _A_FIO0CLR
   \   0000004C                      REQUIRE _A_FIO0SET
    227          /********************************************************************************
    228          *   Descrição   :   Escreve uma sequência de bytes na memória
    229          *   Parametros  :   (unsigned int) endereco inicial
    230          *                   (unsigned char*) buffer que será escrito
    231          *                   (unsigned short int) tamanho do buffer
    232          *   Retorno     :   nenhum
    233          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    234          void SST_writeAutoAddressInc(unsigned int endereco,unsigned char *pData,
    235                                       unsigned short int size){
   \                     SST_writeAutoAddressInc:
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
    236            unsigned char comando[6];
    237            
    238            SST_writeEnable();// Habilita a escrita na memória
   \   00000008   0x.... 0x....      BL       SST_writeEnable
    239            
    240            comando[0] = SST_AAI;
   \   0000000C   0x20AD             MOVS     R0,#+173
   \   0000000E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    241            comando[1] = (unsigned char)(endereco>>16);
   \   00000012   0x0C30             LSRS     R0,R6,#+16
   \   00000014   0xF88D 0x0001      STRB     R0,[SP, #+1]
    242            comando[2] = (unsigned char)(endereco>>8);
   \   00000018   0x0A30             LSRS     R0,R6,#+8
   \   0000001A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    243            comando[3] = (unsigned char)endereco;
   \   0000001E   0xF88D 0x6003      STRB     R6,[SP, #+3]
    244            comando[4] = pData[0];
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0xF88D 0x0004      STRB     R0,[SP, #+4]
    245            comando[5] = pData[1];
   \   00000028   0x7860             LDRB     R0,[R4, #+1]
   \   0000002A   0xF88D 0x0005      STRB     R0,[SP, #+5]
    246            
    247            SEL_CS_01;
   \   0000002E   0x....             LDR.N    R0,??DataTable12_1  ;; 0x2009c01c
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000036   0x....             LDR.N    R1,??DataTable12_1  ;; 0x2009c01c
   \   00000038   0x6008             STR      R0,[R1, #+0]
    248            SPI_sendBytes(comando,6);
   \   0000003A   0x2106             MOVS     R1,#+6
   \   0000003C   0xA800             ADD      R0,SP,#+0
   \   0000003E   0x.... 0x....      BL       SPI_sendBytes
    249            
    250            for(unsigned short int i=0;i<(size-2);i+=2){
   \   00000042   0x2600             MOVS     R6,#+0
   \   00000044   0xE01F             B.N      ??SST_writeAutoAddressInc_0
    251                
    252              SST_busyWait();
   \                     ??SST_writeAutoAddressInc_1:
   \   00000046   0x.... 0x....      BL       SST_busyWait
    253          
    254              comando[0] = SST_AAI;
   \   0000004A   0x20AD             MOVS     R0,#+173
   \   0000004C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    255              comando[1] = pData[2+i];
   \   00000050   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000052   0x1930             ADDS     R0,R6,R4
   \   00000054   0x7880             LDRB     R0,[R0, #+2]
   \   00000056   0xF88D 0x0001      STRB     R0,[SP, #+1]
    256              comando[2] = pData[3+i];
   \   0000005A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000005C   0x1930             ADDS     R0,R6,R4
   \   0000005E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000060   0xF88D 0x0002      STRB     R0,[SP, #+2]
    257                    
    258              SEL_CS_01;
   \   00000064   0x....             LDR.N    R0,??DataTable12_1  ;; 0x2009c01c
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000006C   0x....             LDR.N    R1,??DataTable12_1  ;; 0x2009c01c
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    259              SPI_sendBytes(comando,3);
   \   00000070   0x2103             MOVS     R1,#+3
   \   00000072   0xA800             ADD      R0,SP,#+0
   \   00000074   0x.... 0x....      BL       SPI_sendBytes
    260              UNSEL_CS_01;
   \   00000078   0x....             LDR.N    R0,??DataTable12  ;; 0x2009c018
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000080   0x....             LDR.N    R1,??DataTable12  ;; 0x2009c018
   \   00000082   0x6008             STR      R0,[R1, #+0]
    261            }
   \   00000084   0x1CB6             ADDS     R6,R6,#+2
   \                     ??SST_writeAutoAddressInc_0:
   \   00000086   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000088   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000008A   0x1EA8             SUBS     R0,R5,#+2
   \   0000008C   0x4286             CMP      R6,R0
   \   0000008E   0xDBDA             BLT.N    ??SST_writeAutoAddressInc_1
    262            
    263            SST_busyWait();  
   \   00000090   0x.... 0x....      BL       SST_busyWait
    264              
    265            SST_writeDisable();// Desabilita a escrita na memória
   \   00000094   0x.... 0x....      BL       SST_writeDisable
    266          }
   \   00000098   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   \   0000009A                      REQUIRE _A_FIO0CLR
   \   0000009A                      REQUIRE _A_FIO0SET
    267          /********************************************************************************
    268          *   Descrição     :   Apaga um setor de 4kb na flash
    269          *   Parametros    :   (unsigned short int) número do setor
    270          *   Retorno       :   nenhum
    271          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    272          void SST_erase4kbSector(unsigned int sector){
   \                     SST_erase4kbSector:
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    273            unsigned char comando[4];
    274            SST_status status;
    275            
    276            SST25VF_readStatus(&status);
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      BL       SST25VF_readStatus
    277            status.bp0 = 0;
   \   0000000A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000000E   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
    278            status.bp1 = 0;
   \   00000016   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001A   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   0000001E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    279            status.bp2 = 0;
   \   00000022   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000026   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    280            SST25VF_writeStatus(&status); 
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       SST25VF_writeStatus
    281            
    282            SST_writeEnable();  
   \   00000034   0x.... 0x....      BL       SST_writeEnable
    283          
    284            SEL_CS_01;
   \   00000038   0x....             LDR.N    R0,??DataTable12_1  ;; 0x2009c01c
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000040   0x....             LDR.N    R1,??DataTable12_1  ;; 0x2009c01c
   \   00000042   0x6008             STR      R0,[R1, #+0]
    285          
    286            sector&= ~0xFFF;//Apaga os bits de endereçamento dentro da página
   \   00000044   0x0B24             LSRS     R4,R4,#+12
   \   00000046   0x0324             LSLS     R4,R4,#+12
    287            
    288            comando[0] =  SST_4KB_ERASE;
   \   00000048   0x2020             MOVS     R0,#+32
   \   0000004A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    289            comando[1] = (unsigned char)(sector>>16);
   \   0000004E   0x0C20             LSRS     R0,R4,#+16
   \   00000050   0xF88D 0x0005      STRB     R0,[SP, #+5]
    290            comando[2] = (unsigned char)(sector>>8);
   \   00000054   0x0A20             LSRS     R0,R4,#+8
   \   00000056   0xF88D 0x0006      STRB     R0,[SP, #+6]
    291            comando[3] = (unsigned char) sector;
   \   0000005A   0xF88D 0x4007      STRB     R4,[SP, #+7]
    292            SPI_sendBytes(comando,4);
   \   0000005E   0x2104             MOVS     R1,#+4
   \   00000060   0xA801             ADD      R0,SP,#+4
   \   00000062   0x.... 0x....      BL       SPI_sendBytes
    293            
    294            UNSEL_CS_01;      
   \   00000066   0x....             LDR.N    R0,??DataTable12  ;; 0x2009c018
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000006E   0x....             LDR.N    R1,??DataTable12  ;; 0x2009c018
   \   00000070   0x6008             STR      R0,[R1, #+0]
    295            
    296            SST_busyWait();
   \   00000072   0x.... 0x....      BL       SST_busyWait
    297            
    298            SST_writeDisable();// Desabilita a escrita na memória  
   \   00000076   0x.... 0x....      BL       SST_writeDisable
    299          }
   \   0000007A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   \   0000007C                      REQUIRE _A_FIO0CLR
   \   0000007C                      REQUIRE _A_FIO0SET
    300          /********************************************************************************
    301          *   Descrição     :   Apaga um setor de 32kb
    302          *   Parametros    :   (unsigned short int) número do setor
    303          *   Retorno       :   nenhum
    304          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    305          void SST_erase32kbSector(unsigned int sector){
   \                     SST_erase32kbSector:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    306            unsigned char comando[4];
    307            
    308            SST_writeEnable();
   \   00000006   0x.... 0x....      BL       SST_writeEnable
    309          
    310            SEL_CS_01;
   \   0000000A   0x....             LDR.N    R0,??DataTable12_1  ;; 0x2009c01c
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000012   0x....             LDR.N    R1,??DataTable12_1  ;; 0x2009c01c
   \   00000014   0x6008             STR      R0,[R1, #+0]
    311          
    312            comando[0] =  SST_32KB_ERASE;
   \   00000016   0x2052             MOVS     R0,#+82
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
    313            comando[1] = (unsigned char)(sector>>16);
   \   0000001C   0x0C20             LSRS     R0,R4,#+16
   \   0000001E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    314            comando[2] = (unsigned char)(sector>>8);
   \   00000022   0x0A20             LSRS     R0,R4,#+8
   \   00000024   0xF88D 0x0002      STRB     R0,[SP, #+2]
    315            comando[3] = (unsigned char) sector;
   \   00000028   0xF88D 0x4003      STRB     R4,[SP, #+3]
    316            SPI_sendBytes(comando,4);
   \   0000002C   0x2104             MOVS     R1,#+4
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       SPI_sendBytes
    317            
    318            UNSEL_CS_01;         
   \   00000034   0x....             LDR.N    R0,??DataTable12  ;; 0x2009c018
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000003C   0x....             LDR.N    R1,??DataTable12  ;; 0x2009c018
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    319            
    320            SST_busyWait();
   \   00000040   0x.... 0x....      BL       SST_busyWait
    321            
    322            SST_writeDisable();// Desabilita a escrita na memória  
   \   00000044   0x.... 0x....      BL       SST_writeDisable
    323          }
   \   00000048   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   \   0000004A                      REQUIRE _A_FIO0CLR
   \   0000004A                      REQUIRE _A_FIO0SET
    324          /********************************************************************************
    325          *   Descrição     :   Apaga um setor de 64kb
    326          *   Parametros    :   (unsigned short int) número do setor
    327          *   Retorno       :   nenhum
    328          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    329          void SST_erase64kbSector(unsigned int sector){
   \                     SST_erase64kbSector:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    330            unsigned char comando[4];
    331            
    332            SST_writeEnable();
   \   00000006   0x.... 0x....      BL       SST_writeEnable
    333          
    334            SEL_CS_01;
   \   0000000A   0x....             LDR.N    R0,??DataTable12_1  ;; 0x2009c01c
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000012   0x....             LDR.N    R1,??DataTable12_1  ;; 0x2009c01c
   \   00000014   0x6008             STR      R0,[R1, #+0]
    335          
    336            comando[0] =  SST_64KB_ERASE;
   \   00000016   0x20D8             MOVS     R0,#+216
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
    337            comando[1] = (unsigned char)(sector>>16);
   \   0000001C   0x0C20             LSRS     R0,R4,#+16
   \   0000001E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    338            comando[2] = (unsigned char)(sector>>8);
   \   00000022   0x0A20             LSRS     R0,R4,#+8
   \   00000024   0xF88D 0x0002      STRB     R0,[SP, #+2]
    339            comando[3] = (unsigned char) sector;
   \   00000028   0xF88D 0x4003      STRB     R4,[SP, #+3]
    340            SPI_sendBytes(comando,4);
   \   0000002C   0x2104             MOVS     R1,#+4
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       SPI_sendBytes
    341            
    342            SST_busyWait();
   \   00000034   0x.... 0x....      BL       SST_busyWait
    343            
    344            UNSEL_CS_01;           
   \   00000038   0x....             LDR.N    R0,??DataTable12  ;; 0x2009c018
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000040   0x....             LDR.N    R1,??DataTable12  ;; 0x2009c018
   \   00000042   0x6008             STR      R0,[R1, #+0]
    345            SST_writeDisable();// Desabilita a escrita na memória  
   \   00000044   0x.... 0x....      BL       SST_writeDisable
    346          }
   \   00000048   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   \   0000004A                      REQUIRE _A_FIO0CLR
   \   0000004A                      REQUIRE _A_FIO0SET
    347          /********************************************************************************
    348          *   Descrição     :   Apaga todo o chip
    349          *   Parametros    :   nenhum
    350          *   Retorno       :   nenhum
    351          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    352          void SST_chipErase(void){
   \                     SST_chipErase:
   \   00000000   0xB580             PUSH     {R7,LR}
    353            unsigned char comando;
    354            
    355            SST_writeEnable();
   \   00000002   0x.... 0x....      BL       SST_writeEnable
    356          
    357            SEL_CS_01;
   \   00000006   0x....             LDR.N    R0,??DataTable12_1  ;; 0x2009c01c
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000000E   0x....             LDR.N    R1,??DataTable12_1  ;; 0x2009c01c
   \   00000010   0x6008             STR      R0,[R1, #+0]
    358          
    359            comando =  SST_CHIP_ERASE;
   \   00000012   0x2060             MOVS     R0,#+96
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    360            SPI_sendBytes(&comando,1);
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0xA800             ADD      R0,SP,#+0
   \   0000001C   0x.... 0x....      BL       SPI_sendBytes
    361            
    362            UNSEL_CS_01;           
   \   00000020   0x....             LDR.N    R0,??DataTable12  ;; 0x2009c018
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000028   0x....             LDR.N    R1,??DataTable12  ;; 0x2009c018
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    363            SST_busyWait();
   \   0000002C   0x.... 0x....      BL       SST_busyWait
    364            SST_writeDisable();// Desabilita a escrita na memória  
   \   00000030   0x.... 0x....      BL       SST_writeDisable
    365          }
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
   \   00000036                      REQUIRE _A_FIO0CLR
   \   00000036                      REQUIRE _A_FIO0SET

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x2009C018         DC32     0x2009c018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x2009C01C         DC32     0x2009c01c
    366          /********************************************************************************
    367          *   Fim do arquivo
    368          ********************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   SST25VF_init
      16   SST25VF_readStatus
        16   -> SPI_getBytes
        16   -> SPI_sendBytes
      16   SST25VF_writeStatus
        16   -> SPI_sendBytes
        16   -> SST25VF_readStatus
       8   SST_busyWait
         8   -> SST25VF_readStatus
       8   SST_chipErase
         8   -> SPI_sendBytes
         8   -> SST_busyWait
         8   -> SST_writeDisable
         8   -> SST_writeEnable
      16   SST_erase32kbSector
        16   -> SPI_sendBytes
        16   -> SST_busyWait
        16   -> SST_writeDisable
        16   -> SST_writeEnable
      16   SST_erase4kbSector
        16   -> SPI_sendBytes
        16   -> SST25VF_readStatus
        16   -> SST25VF_writeStatus
        16   -> SST_busyWait
        16   -> SST_writeDisable
        16   -> SST_writeEnable
      16   SST_erase64kbSector
        16   -> SPI_sendBytes
        16   -> SST_busyWait
        16   -> SST_writeDisable
        16   -> SST_writeEnable
      24   SST_highSpeedRead
        24   -> SPI_getBytes
        24   -> SPI_sendBytes
       8   SST_readID
         8   -> SPI_getBytes
         8   -> SPI_sendBytes
      24   SST_writeAutoAddressInc
        24   -> SPI_sendBytes
        24   -> SST_busyWait
        24   -> SST_writeDisable
        24   -> SST_writeEnable
      24   SST_writeByte
        24   -> SPI_sendBytes
        24   -> SST_writeDisable
        24   -> SST_writeEnable
       8   SST_writeDisable
         8   -> SPI_sendBytes
       8   SST_writeEnable
         8   -> SPI_sendBytes


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
      34  SST25VF_init
      62  SST25VF_readStatus
     114  SST25VF_writeStatus
      22  SST_busyWait
      54  SST_chipErase
      74  SST_erase32kbSector
     124  SST_erase4kbSector
      74  SST_erase64kbSector
      80  SST_highSpeedRead
      82  SST_readID
     154  SST_writeAutoAddressInc
      76  SST_writeByte
      42  SST_writeDisable
      42  SST_writeEnable
       4  _A_FIO0CLR
       4  _A_FIO0SET

 
     8 bytes in section .noinit (abs)
 1 042 bytes in section .text
 
 1 042 bytes of CODE memory
     0 bytes of DATA memory (+ 8 bytes shared)

Errors: none
Warnings: none
