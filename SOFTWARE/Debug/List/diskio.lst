###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      12/Jul/2017  11:51:17 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Drivers\FILESYSTEM\diskio.c               #
#    Command line =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Drivers\FILESYSTEM\diskio.c -lC           #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\ -lA                           #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\ -o                            #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\Obj\ --no_cse --no_unroll           #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -Ol                                               #
#    List file    =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\diskio.lst                     #
#    Object file  =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\Obj\diskio.o                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPipocaG2\SOFTWARE\Drivers\FILESYSTEM\diskio.c
      1          /*__________________________________________________________________________________
      2          |	Chave Digital Tecnologia Eletronica Ltda. 
      3          |       
      4          |       Balneário Camboriú - SC
      5          |       www.chavedigital.com.br
      6          | __________________________________________________________________________________
      7          |
      8          |       This source code was developed by Chave Digital and cannot be copied, in part 
      9          |       or in whole, or used, except when legally licensed by Chave Digital
     10          |       or its distributors.
     11          |
     12          |       Este código é propriedade da Chave Digital e não pode ser copiado, em parte 
     13          |       ou em todo, ou utilizado, exceto quando for legalmente licenciado pela 
     14          |       Chave Digital ou por um de seus distribuidores.
     15          | __________________________________________________________________________________
     16          |
     17          |       Arquivo            :  diskio.c
     18          |       Descrição          :  Middleware para o acesso à memória física
     19          |                             DATAFLASH OU SDCARD
     20          | 
     21          |       Autor              :  Marcos Aquino
     22          |       Data criação       :  01/08/2011
     23          |
     24          |       Revisões           :  1.0
     25          |
     26          |
     27          | __________________________________________________________________________________
     28          */
     29          /***********************************************************************************
     30          *		Includes
     31          ***********************************************************************************/
     32          #include <nxp\iolpc1768.h>
     33          #include "diskio.h"
     34          #include "sd_diskio.h"
     35          #include "dataflash_diskio.h"
     36          #include "..\rtc\rtc.h"
     37          /***********************************************************************************
     38          *		Definições com constantes utilizadas no programa
     39          ***********************************************************************************/ 
     40          
     41          
     42          
     43          /***********************************************************************************
     44          *		Enumerações
     45          ***********************************************************************************/
     46          
     47          
     48          /***********************************************************************************
     49          *		Estruturas
     50          ***********************************************************************************/
     51          
     52          
     53          /***********************************************************************************
     54          *		Uniões
     55          ***********************************************************************************/
     56          
     57          
     58          /***********************************************************************************
     59          *		Constantes
     60          ***********************************************************************************/
     61          
     62          
     63          /***********************************************************************************
     64          *		Variaveis locais
     65          ***********************************************************************************/
     66          
     67          
     68          /***********************************************************************************
     69          *		Funções locais
     70          ***********************************************************************************/
     71           
     72          /***********************************************************************************
     73          *		Implementação
     74          ***********************************************************************************/
     75          
     76          /***********************************************************************************
     77          *   Descrição   :   Inicialização dos drives do sistema
     78          *   Parametros  :   (unsigned char) número do drive
     79          *   Retorno     :   (DSTATUS) 
     80          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     81          DSTATUS disk_initialize(unsigned char drv){
   \                     disk_initialize:
   \   00000000   0xB580             PUSH     {R7,LR}
     82            
     83            switch(drv){
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD002             BEQ.N    ??disk_initialize_0
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD004             BEQ.N    ??disk_initialize_1
   \   0000000C   0xE007             B.N      ??disk_initialize_2
     84             case DRIVE_SD        : return (DSTATUS)SD_disk_initialize();               
   \                     ??disk_initialize_0:
   \   0000000E   0x.... 0x....      BL       SD_disk_initialize
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xE004             B.N      ??disk_initialize_3
     85             case DRIVE_DATAFLASH : return (DSTATUS)DF_disk_initialize();
   \                     ??disk_initialize_1:
   \   00000016   0x.... 0x....      BL       DF_disk_initialize
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xE000             B.N      ??disk_initialize_3
     86            }
     87            
     88            return STA_NOINIT;  
   \                     ??disk_initialize_2:
   \   0000001E   0x2001             MOVS     R0,#+1
   \                     ??disk_initialize_3:
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
     89          }
     90          /***********************************************************************************
     91          *     Descrição   :   Lê o status do disco passado no parametro
     92          *     Parametros  :   (unsigned char) número do drive
     93          *     Retorno     :   nenhum
     94          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     95          DSTATUS disk_status (unsigned char drv){
   \                     disk_status:
   \   00000000   0xB580             PUSH     {R7,LR}
     96          
     97            switch(drv){
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD002             BEQ.N    ??disk_status_0
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD003             BEQ.N    ??disk_status_1
   \   0000000C   0xE005             B.N      ??disk_status_2
     98             case DRIVE_SD        : return (DSTATUS)SD_disk_status();               
   \                     ??disk_status_0:
   \   0000000E   0x.... 0x....      BL       SD_disk_status
   \   00000012   0xE003             B.N      ??disk_status_3
     99             case DRIVE_DATAFLASH : return (DSTATUS)DF_disk_status();
   \                     ??disk_status_1:
   \   00000014   0x.... 0x....      BL       DF_disk_status
   \   00000018   0xE000             B.N      ??disk_status_3
    100            }  
    101            
    102            return STA_NOINIT;  
   \                     ??disk_status_2:
   \   0000001A   0x2001             MOVS     R0,#+1
   \                     ??disk_status_3:
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
    103          }
    104          /***********************************************************************************
    105          *     Descrição   :   Lê um setor de uma das unidades de disco
    106          *     Parametros  :   (unsigned char) drive
    107          *                     (unsigned char*) buffer
    108          *                     (unsigned long int) setor
    109          *                     (unsigned char) tamanho do bloco lido
    110          *     Retorno     :   (DRESULT)
    111          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    112          DRESULT disk_read (unsigned char drv,unsigned char *buffer,
    113                             DWORD sector,unsigned char count){/* Physical drive number (0) */
   \                     disk_read:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
   \   00000004   0x0011             MOVS     R1,R2
   \   00000006   0x001A             MOVS     R2,R3
    114          
    115            switch(drv){
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD002             BEQ.N    ??disk_read_0
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD005             BEQ.N    ??disk_read_1
   \   00000012   0xE009             B.N      ??disk_read_2
    116             case DRIVE_SD        : return (DRESULT)SD_disk_read(buffer,sector,count);
   \                     ??disk_read_0:
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       SD_disk_read
   \   0000001C   0xE005             B.N      ??disk_read_3
    117             case DRIVE_DATAFLASH : return (DRESULT)DF_disk_read(buffer,sector,count);
   \                     ??disk_read_1:
   \   0000001E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       DF_disk_read
   \   00000026   0xE000             B.N      ??disk_read_3
    118            }                     
    119            
    120            return RES_NOTRDY;  
   \                     ??disk_read_2:
   \   00000028   0x2003             MOVS     R0,#+3
   \                     ??disk_read_3:
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    121          }
    122          /***********************************************************************************
    123          *     Descrição   :   Escreve em um setor de um determinado disco
    124          *     Parametros  :   (unsigned char) drive
    125          *                     (unsigned char*) buffer
    126          *                     (unsigned int) número do setor
    127          *                     (unsigned char) tamanho do bloco escrito
    128          *     Retorno     :   (DRESULT)
    129          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    130          DRESULT disk_write(unsigned char drv,const unsigned char *buff,
    131                             DWORD sector,unsigned char byte){
   \                     disk_write:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
   \   00000004   0x0011             MOVS     R1,R2
   \   00000006   0x001A             MOVS     R2,R3
    132          
    133            switch(drv){
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD002             BEQ.N    ??disk_write_0
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD005             BEQ.N    ??disk_write_1
   \   00000012   0xE009             B.N      ??disk_write_2
    134             case DRIVE_SD        : return (DRESULT)SD_disk_write((unsigned char*)buff,sector,byte);              
   \                     ??disk_write_0:
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       SD_disk_write
   \   0000001C   0xE005             B.N      ??disk_write_3
    135             case DRIVE_DATAFLASH : return (DRESULT)DF_disk_write((unsigned char*)buff,sector,byte);              
   \                     ??disk_write_1:
   \   0000001E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       DF_disk_write
   \   00000026   0xE000             B.N      ??disk_write_3
    136            }                     
    137            
    138            return RES_NOTRDY;
   \                     ??disk_write_2:
   \   00000028   0x2003             MOVS     R0,#+3
   \                     ??disk_write_3:
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    139          }
    140          /***********************************************************************************
    141          *   Descrição   :   Controle de funções específicas do disco
    142          *   Parametros  :   (unsigned char) drive
    143          *                   (unsigned char) comando
    144          *                   (void*) ponteiro para a estrutura de controle do 
    145          *                   comando que será executado
    146          *   Retorno     :   nenhum
    147          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    148          DRESULT disk_ioctl(unsigned char drv,unsigned char ctrl,void *buff){
   \                     disk_ioctl:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x000B             MOVS     R3,R1
   \   00000004   0x0011             MOVS     R1,R2
    149          
    150            switch(drv){
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??disk_ioctl_0
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD005             BEQ.N    ??disk_ioctl_1
   \   00000010   0xE009             B.N      ??disk_ioctl_2
    151             case DRIVE_SD        : return (DRESULT)SD_disk_ioctl(ctrl,buff);               
   \                     ??disk_ioctl_0:
   \   00000012   0x0018             MOVS     R0,R3
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       SD_disk_ioctl
   \   0000001A   0xE005             B.N      ??disk_ioctl_3
    152             case DRIVE_DATAFLASH : return (DRESULT)DF_disk_ioctl(ctrl,buff);  
   \                     ??disk_ioctl_1:
   \   0000001C   0x0018             MOVS     R0,R3
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       DF_disk_ioctl
   \   00000024   0xE000             B.N      ??disk_ioctl_3
    153            }  
    154            
    155            return RES_NOTRDY;
   \                     ??disk_ioctl_2:
   \   00000026   0x2003             MOVS     R0,#+3
   \                     ??disk_ioctl_3:
   \   00000028   0xBD02             POP      {R1,PC}          ;; return
    156          }
    157          /***********************************************************************************
    158          *   Descrição   :   Função para leitura do relógio
    159          *   Parametros  :   nenhum
    160          *   Retorno     :   nenhum
    161          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    162          DWORD get_fattime(void){
   \                     get_fattime:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    163            unsigned char hora,minuto,segundo,dia,mes;
    164            unsigned int ano;  
    165            DWORD relogio=0;
   \   00000004   0x2400             MOVS     R4,#+0
    166            
    167            RTC_getValue(&hora,&minuto,&segundo,&dia,&mes,&ano);
   \   00000006   0xA804             ADD      R0,SP,#+16
   \   00000008   0x9001             STR      R0,[SP, #+4]
   \   0000000A   0xA802             ADD      R0,SP,#+8
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0xF10D 0x030A      ADD      R3,SP,#+10
   \   00000012   0xF10D 0x0209      ADD      R2,SP,#+9
   \   00000016   0xF10D 0x010B      ADD      R1,SP,#+11
   \   0000001A   0xA803             ADD      R0,SP,#+12
   \   0000001C   0x.... 0x....      BL       RTC_getValue
    168            
    169            if(ano>2000)
   \   00000020   0x9804             LDR      R0,[SP, #+16]
   \   00000022   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   00000026   0xD904             BLS.N    ??get_fattime_0
    170              ano-=2000;
   \   00000028   0x9804             LDR      R0,[SP, #+16]
   \   0000002A   0xF5B0 0x60FA      SUBS     R0,R0,#+2000
   \   0000002E   0x9004             STR      R0,[SP, #+16]
   \   00000030   0xE001             B.N      ??get_fattime_1
    171            else
    172              ano = 32;
   \                     ??get_fattime_0:
   \   00000032   0x2020             MOVS     R0,#+32
   \   00000034   0x9004             STR      R0,[SP, #+16]
    173            ano&= 0x7F;
   \                     ??get_fattime_1:
   \   00000036   0x9804             LDR      R0,[SP, #+16]
   \   00000038   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   0000003C   0x9004             STR      R0,[SP, #+16]
    174            relogio = ano;
   \   0000003E   0x9C04             LDR      R4,[SP, #+16]
    175          
    176            if(mes>12)
   \   00000040   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000044   0x280D             CMP      R0,#+13
   \   00000046   0xDB02             BLT.N    ??get_fattime_2
    177              mes = 12;
   \   00000048   0x200C             MOVS     R0,#+12
   \   0000004A   0xF88D 0x0008      STRB     R0,[SP, #+8]
    178            mes &= 0x0F;
   \                     ??get_fattime_2:
   \   0000004E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000052   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000056   0xF88D 0x0008      STRB     R0,[SP, #+8]
    179            relogio<<=4;
   \   0000005A   0x0124             LSLS     R4,R4,#+4
    180            relogio|= mes;
   \   0000005C   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000060   0x4304             ORRS     R4,R0,R4
    181            
    182            if(dia>31)
   \   00000062   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   00000066   0x2820             CMP      R0,#+32
   \   00000068   0xDB02             BLT.N    ??get_fattime_3
    183              dia =31;
   \   0000006A   0x201F             MOVS     R0,#+31
   \   0000006C   0xF88D 0x000A      STRB     R0,[SP, #+10]
    184            relogio<<=5;
   \                     ??get_fattime_3:
   \   00000070   0x0164             LSLS     R4,R4,#+5
    185            relogio|=dia;
   \   00000072   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   00000076   0x4304             ORRS     R4,R0,R4
    186            
    187            if(hora>23)
   \   00000078   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000007C   0x2818             CMP      R0,#+24
   \   0000007E   0xDB02             BLT.N    ??get_fattime_4
    188              hora=23;
   \   00000080   0x2017             MOVS     R0,#+23
   \   00000082   0xF88D 0x000C      STRB     R0,[SP, #+12]
    189            relogio<<=5;
   \                     ??get_fattime_4:
   \   00000086   0x0164             LSLS     R4,R4,#+5
    190            relogio |= hora;
   \   00000088   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000008C   0x4304             ORRS     R4,R0,R4
    191            
    192            if(minuto>59)
   \   0000008E   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000092   0x283C             CMP      R0,#+60
   \   00000094   0xDB02             BLT.N    ??get_fattime_5
    193              minuto = 59;
   \   00000096   0x203B             MOVS     R0,#+59
   \   00000098   0xF88D 0x000B      STRB     R0,[SP, #+11]
    194            relogio<<=5;
   \                     ??get_fattime_5:
   \   0000009C   0x0164             LSLS     R4,R4,#+5
    195            relogio|=minuto;
   \   0000009E   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   000000A2   0x4304             ORRS     R4,R0,R4
    196            
    197            if(segundo>59)
   \   000000A4   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   000000A8   0x283C             CMP      R0,#+60
   \   000000AA   0xDB02             BLT.N    ??get_fattime_6
    198              segundo=59;
   \   000000AC   0x203B             MOVS     R0,#+59
   \   000000AE   0xF88D 0x0009      STRB     R0,[SP, #+9]
    199            segundo>>=1;
   \                     ??get_fattime_6:
   \   000000B2   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x0840             LSRS     R0,R0,#+1
   \   000000BA   0xF88D 0x0009      STRB     R0,[SP, #+9]
    200            relogio<<=4;
   \   000000BE   0x0124             LSLS     R4,R4,#+4
    201            relogio|= segundo;
   \   000000C0   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   000000C4   0x4304             ORRS     R4,R0,R4
    202            
    203            return relogio; 
   \   000000C6   0x0020             MOVS     R0,R4
   \   000000C8   0xB006             ADD      SP,SP,#+24
   \   000000CA   0xBD10             POP      {R4,PC}          ;; return
    204          }
    205          /***********************************************************************************
    206          *		Fim do arquivo
    207          ***********************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   disk_initialize
         8   -> DF_disk_initialize
         8   -> SD_disk_initialize
       8   disk_ioctl
         8   -> DF_disk_ioctl
         8   -> SD_disk_ioctl
       8   disk_read
         8   -> DF_disk_read
         8   -> SD_disk_read
       8   disk_status
         8   -> DF_disk_status
         8   -> SD_disk_status
       8   disk_write
         8   -> DF_disk_write
         8   -> SD_disk_write
      32   get_fattime
        32   -> RTC_getValue


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      34  disk_initialize
      42  disk_ioctl
      44  disk_read
      30  disk_status
      44  disk_write
     204  get_fattime

 
 398 bytes in section .text
 
 398 bytes of CODE memory

Errors: none
Warnings: none
