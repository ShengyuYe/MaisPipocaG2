###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      06/Jul/2017  16:40:32 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Drivers\FILESYSTEM\diskio.c               #
#    Command line =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Drivers\FILESYSTEM\diskio.c -lC           #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\ -lA                           #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\ -o                            #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\Obj\ --no_cse --no_unroll           #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -Ol                                               #
#    List file    =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\diskio.lst                     #
#    Object file  =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\Obj\diskio.o                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPipocaG2\SOFTWARE\Drivers\FILESYSTEM\diskio.c
      1          /*__________________________________________________________________________________
      2          |	Chave Digital Tecnologia Eletronica Ltda. 
      3          |       
      4          |       Balneário Camboriú - SC
      5          |       www.chavedigital.com.br
      6          | __________________________________________________________________________________
      7          |
      8          |       This source code was developed by Chave Digital and cannot be copied, in part 
      9          |       or in whole, or used, except when legally licensed by Chave Digital
     10          |       or its distributors.
     11          |
     12          |       Este código é propriedade da Chave Digital e não pode ser copiado, em parte 
     13          |       ou em todo, ou utilizado, exceto quando for legalmente licenciado pela 
     14          |       Chave Digital ou por um de seus distribuidores.
     15          | __________________________________________________________________________________
     16          |
     17          |       Arquivo            :  diskio.c
     18          |       Descrição          :  Middleware para o acesso à memória física
     19          |                             DATAFLASH OU SDCARD
     20          | 
     21          |       Autor              :  Marcos Aquino
     22          |       Data criação       :  01/08/2011
     23          |
     24          |       Revisões           :  1.0
     25          |
     26          |
     27          | __________________________________________________________________________________
     28          */
     29          /***********************************************************************************
     30          *		Includes
     31          ***********************************************************************************/
     32          #include <nxp\iolpc1768.h>
     33          #include "diskio.h"
     34          #include "sd_diskio.h"
     35          #include "..\rtc\rtc.h"
     36          /***********************************************************************************
     37          *		Definições com constantes utilizadas no programa
     38          ***********************************************************************************/ 
     39          
     40          
     41          
     42          /***********************************************************************************
     43          *		Enumerações
     44          ***********************************************************************************/
     45          
     46          
     47          /***********************************************************************************
     48          *		Estruturas
     49          ***********************************************************************************/
     50          
     51          
     52          /***********************************************************************************
     53          *		Uniões
     54          ***********************************************************************************/
     55          
     56          
     57          /***********************************************************************************
     58          *		Constantes
     59          ***********************************************************************************/
     60          
     61          
     62          /***********************************************************************************
     63          *		Variaveis locais
     64          ***********************************************************************************/
     65          
     66          
     67          /***********************************************************************************
     68          *		Funções locais
     69          ***********************************************************************************/
     70           
     71          /***********************************************************************************
     72          *		Implementação
     73          ***********************************************************************************/
     74          
     75          /***********************************************************************************
     76          *   Descrição   :   Inicialização dos drives do sistema
     77          *   Parametros  :   (unsigned char) número do drive
     78          *   Retorno     :   (DSTATUS) 
     79          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     80          DSTATUS disk_initialize(unsigned char drv){
   \                     disk_initialize:
   \   00000000   0xB580             PUSH     {R7,LR}
     81            
     82            switch(drv){
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD103             BNE.N    ??disk_initialize_0
     83             case DRIVE_SD        : return (DSTATUS)SD_disk_initialize();               
   \   00000008   0x.... 0x....      BL       SD_disk_initialize
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0xE000             B.N      ??disk_initialize_1
     84          //   case DRIVE_DATAFLASH : return (DSTATUS)DataFlash_initialize();
     85            }
     86            
     87            return STA_NOINIT;  
   \                     ??disk_initialize_0:
   \   00000010   0x2001             MOVS     R0,#+1
   \                     ??disk_initialize_1:
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
     88          }
     89          /***********************************************************************************
     90          *     Descrição   :   Lê o status do disco passado no parametro
     91          *     Parametros  :   (unsigned char) número do drive
     92          *     Retorno     :   nenhum
     93          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     94          DSTATUS disk_status (unsigned char drv){
   \                     disk_status:
   \   00000000   0xB580             PUSH     {R7,LR}
     95          
     96            switch(drv){
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD102             BNE.N    ??disk_status_0
     97             case DRIVE_SD        : return (DSTATUS)SD_disk_status();               
   \   00000008   0x.... 0x....      BL       SD_disk_status
   \   0000000C   0xE000             B.N      ??disk_status_1
     98          //   case DRIVE_DATAFLASH : return (DSTATUS)DataFlash_status();
     99            }  
    100            
    101            return STA_NOINIT;  
   \                     ??disk_status_0:
   \   0000000E   0x2001             MOVS     R0,#+1
   \                     ??disk_status_1:
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    102          }
    103          /***********************************************************************************
    104          *     Descrição   :   Lê um setor de uma das unidades de disco
    105          *     Parametros  :   (unsigned char) drive
    106          *                     (unsigned char*) buffer
    107          *                     (unsigned long int) setor
    108          *                     (unsigned char) tamanho do bloco lido
    109          *     Retorno     :   (DRESULT)
    110          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    111          DRESULT disk_read (unsigned char drv,unsigned char *buffer,
    112                             DWORD sector,unsigned char count){/* Physical drive number (0) */
   \                     disk_read:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
   \   00000004   0x0011             MOVS     R1,R2
   \   00000006   0x001A             MOVS     R2,R3
    113          
    114            switch(drv){
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD104             BNE.N    ??disk_read_0
    115             case DRIVE_SD        : return (DRESULT)SD_disk_read(buffer,sector,count);
   \   0000000E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       SD_disk_read
   \   00000016   0xE000             B.N      ??disk_read_1
    116          //   case DRIVE_DATAFLASH : return (DRESULT)DataFlash_read(buffer,sector,count);
    117            }                     
    118            
    119            return RES_NOTRDY;  
   \                     ??disk_read_0:
   \   00000018   0x2003             MOVS     R0,#+3
   \                     ??disk_read_1:
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    120          }
    121          /***********************************************************************************
    122          *     Descrição   :   Escreve em um setor de um determinado disco
    123          *     Parametros  :   (unsigned char) drive
    124          *                     (unsigned char*) buffer
    125          *                     (unsigned int) número do setor
    126          *                     (unsigned char) tamanho do bloco escrito
    127          *     Retorno     :   (DRESULT)
    128          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    129          DRESULT disk_write(unsigned char drv,const unsigned char *buff,
    130                             DWORD sector,unsigned char byte){
   \                     disk_write:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
   \   00000004   0x0011             MOVS     R1,R2
   \   00000006   0x001A             MOVS     R2,R3
    131          
    132            switch(drv){
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD104             BNE.N    ??disk_write_0
    133             case DRIVE_SD        : return (DRESULT)SD_disk_write((unsigned char*)buff,sector,byte);              
   \   0000000E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       SD_disk_write
   \   00000016   0xE000             B.N      ??disk_write_1
    134          //   case DRIVE_DATAFLASH : return (DRESULT)DataFlash_write((unsigned char*)buff,sector,byte);              
    135            }                     
    136            
    137            return RES_NOTRDY;
   \                     ??disk_write_0:
   \   00000018   0x2003             MOVS     R0,#+3
   \                     ??disk_write_1:
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    138          }
    139          /***********************************************************************************
    140          *   Descrição   :   Controle de funções específicas do disco
    141          *   Parametros  :   (unsigned char) drive
    142          *                   (unsigned char) comando
    143          *                   (void*) ponteiro para a estrutura de controle do 
    144          *                   comando que será executado
    145          *   Retorno     :   nenhum
    146          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    147          DRESULT disk_ioctl(unsigned char drv,unsigned char ctrl,void *buff){
   \                     disk_ioctl:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x000B             MOVS     R3,R1
   \   00000004   0x0011             MOVS     R1,R2
    148          
    149            switch(drv){
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD104             BNE.N    ??disk_ioctl_0
    150             case DRIVE_SD        : return (DRESULT)SD_disk_ioctl(ctrl,buff);               
   \   0000000C   0x0018             MOVS     R0,R3
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       SD_disk_ioctl
   \   00000014   0xE000             B.N      ??disk_ioctl_1
    151          //   case DRIVE_DATAFLASH : return (DRESULT)DataFlash_ioctl(ctrl,buff);  
    152            }  
    153            
    154            return RES_NOTRDY;
   \                     ??disk_ioctl_0:
   \   00000016   0x2003             MOVS     R0,#+3
   \                     ??disk_ioctl_1:
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    155          }
    156          /***********************************************************************************
    157          *   Descrição   :   Função para leitura do relógio
    158          *   Parametros  :   nenhum
    159          *   Retorno     :   nenhum
    160          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    161          DWORD get_fattime(void){
   \                     get_fattime:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    162            unsigned char hora,minuto,segundo,dia,mes;
    163            unsigned int ano;  
    164            DWORD relogio=0;
   \   00000004   0x2400             MOVS     R4,#+0
    165            
    166            RTC_getValue(&hora,&minuto,&segundo,&dia,&mes,&ano);
   \   00000006   0xA804             ADD      R0,SP,#+16
   \   00000008   0x9001             STR      R0,[SP, #+4]
   \   0000000A   0xA802             ADD      R0,SP,#+8
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0xF10D 0x030A      ADD      R3,SP,#+10
   \   00000012   0xF10D 0x0209      ADD      R2,SP,#+9
   \   00000016   0xF10D 0x010B      ADD      R1,SP,#+11
   \   0000001A   0xA803             ADD      R0,SP,#+12
   \   0000001C   0x.... 0x....      BL       RTC_getValue
    167            
    168            if(ano>2000)
   \   00000020   0x9804             LDR      R0,[SP, #+16]
   \   00000022   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   00000026   0xD904             BLS.N    ??get_fattime_0
    169              ano-=2000;
   \   00000028   0x9804             LDR      R0,[SP, #+16]
   \   0000002A   0xF5B0 0x60FA      SUBS     R0,R0,#+2000
   \   0000002E   0x9004             STR      R0,[SP, #+16]
   \   00000030   0xE001             B.N      ??get_fattime_1
    170            else
    171              ano = 32;
   \                     ??get_fattime_0:
   \   00000032   0x2020             MOVS     R0,#+32
   \   00000034   0x9004             STR      R0,[SP, #+16]
    172            ano&= 0x7F;
   \                     ??get_fattime_1:
   \   00000036   0x9804             LDR      R0,[SP, #+16]
   \   00000038   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   0000003C   0x9004             STR      R0,[SP, #+16]
    173            relogio = ano;
   \   0000003E   0x9C04             LDR      R4,[SP, #+16]
    174          
    175            if(mes>12)
   \   00000040   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000044   0x280D             CMP      R0,#+13
   \   00000046   0xDB02             BLT.N    ??get_fattime_2
    176              mes = 12;
   \   00000048   0x200C             MOVS     R0,#+12
   \   0000004A   0xF88D 0x0008      STRB     R0,[SP, #+8]
    177            mes &= 0x0F;
   \                     ??get_fattime_2:
   \   0000004E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000052   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000056   0xF88D 0x0008      STRB     R0,[SP, #+8]
    178            relogio<<=4;
   \   0000005A   0x0124             LSLS     R4,R4,#+4
    179            relogio|= mes;
   \   0000005C   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000060   0x4304             ORRS     R4,R0,R4
    180            
    181            if(dia>31)
   \   00000062   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   00000066   0x2820             CMP      R0,#+32
   \   00000068   0xDB02             BLT.N    ??get_fattime_3
    182              dia =31;
   \   0000006A   0x201F             MOVS     R0,#+31
   \   0000006C   0xF88D 0x000A      STRB     R0,[SP, #+10]
    183            relogio<<=5;
   \                     ??get_fattime_3:
   \   00000070   0x0164             LSLS     R4,R4,#+5
    184            relogio|=dia;
   \   00000072   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   00000076   0x4304             ORRS     R4,R0,R4
    185            
    186            if(hora>23)
   \   00000078   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000007C   0x2818             CMP      R0,#+24
   \   0000007E   0xDB02             BLT.N    ??get_fattime_4
    187              hora=23;
   \   00000080   0x2017             MOVS     R0,#+23
   \   00000082   0xF88D 0x000C      STRB     R0,[SP, #+12]
    188            relogio<<=5;
   \                     ??get_fattime_4:
   \   00000086   0x0164             LSLS     R4,R4,#+5
    189            relogio |= hora;
   \   00000088   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000008C   0x4304             ORRS     R4,R0,R4
    190            
    191            if(minuto>59)
   \   0000008E   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000092   0x283C             CMP      R0,#+60
   \   00000094   0xDB02             BLT.N    ??get_fattime_5
    192              minuto = 59;
   \   00000096   0x203B             MOVS     R0,#+59
   \   00000098   0xF88D 0x000B      STRB     R0,[SP, #+11]
    193            relogio<<=5;
   \                     ??get_fattime_5:
   \   0000009C   0x0164             LSLS     R4,R4,#+5
    194            relogio|=minuto;
   \   0000009E   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   000000A2   0x4304             ORRS     R4,R0,R4
    195            
    196            if(segundo>59)
   \   000000A4   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   000000A8   0x283C             CMP      R0,#+60
   \   000000AA   0xDB02             BLT.N    ??get_fattime_6
    197              segundo=59;
   \   000000AC   0x203B             MOVS     R0,#+59
   \   000000AE   0xF88D 0x0009      STRB     R0,[SP, #+9]
    198            segundo>>=1;
   \                     ??get_fattime_6:
   \   000000B2   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x0840             LSRS     R0,R0,#+1
   \   000000BA   0xF88D 0x0009      STRB     R0,[SP, #+9]
    199            relogio<<=4;
   \   000000BE   0x0124             LSLS     R4,R4,#+4
    200            relogio|= segundo;
   \   000000C0   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   000000C4   0x4304             ORRS     R4,R0,R4
    201            
    202            return relogio; 
   \   000000C6   0x0020             MOVS     R0,R4
   \   000000C8   0xB006             ADD      SP,SP,#+24
   \   000000CA   0xBD10             POP      {R4,PC}          ;; return
    203          }
    204          /***********************************************************************************
    205          *		Fim do arquivo
    206          ***********************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   disk_initialize
         8   -> SD_disk_initialize
       8   disk_ioctl
         8   -> SD_disk_ioctl
       8   disk_read
         8   -> SD_disk_read
       8   disk_status
         8   -> SD_disk_status
       8   disk_write
         8   -> SD_disk_write
      32   get_fattime
        32   -> RTC_getValue


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  disk_initialize
      26  disk_ioctl
      28  disk_read
      18  disk_status
      28  disk_write
     204  get_fattime

 
 324 bytes in section .text
 
 324 bytes of CODE memory

Errors: none
Warnings: none
