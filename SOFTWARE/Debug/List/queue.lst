###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      08/Sep/2017  19:51:57 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\repositorios\MaisPipocaG2\SOFTWARE\Kernel\queue.c     #
#    Command line =  C:\repositorios\MaisPipocaG2\SOFTWARE\Kernel\queue.c     #
#                    -lC C:\repositorios\MaisPipocaG2\SOFTWARE\Debug\List\    #
#                    -lA C:\repositorios\MaisPipocaG2\SOFTWARE\Debug\List\    #
#                    -o C:\repositorios\MaisPipocaG2\SOFTWARE\Debug\Obj\      #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -On                                               #
#    List file    =  C:\repositorios\MaisPipocaG2\SOFTWARE\Debug\List\queue.l #
#                    st                                                       #
#    Object file  =  C:\repositorios\MaisPipocaG2\SOFTWARE\Debug\Obj\queue.o  #
#                                                                             #
#                                                                             #
###############################################################################

C:\repositorios\MaisPipocaG2\SOFTWARE\Kernel\queue.c
      1          /*__________________________________________________________________________________
      2          |	Quark Tecnologia Eletrônica Embarcada
      3          |       
      4          |       Itapema - SC
      5          |       www.quarktee.com.br
      6          | __________________________________________________________________________________
      7          |
      8          |       This source code was developed by Quark  and cannot be copied, in part 
      9          |       or in whole, or used, except when legally licensed by Quark 
     10          |       or its distributors.
     11          |
     12          |       Este código é propriedade da Quark  e não pode ser copiado, em parte 
     13          |       ou em todo, ou utilizado, exceto quando for legalmente licenciado pela 
     14          |       Quark  ou por um de seus distribuidores.
     15          | __________________________________________________________________________________
     16          |
     17          |       Arquivo            :
     18          |       Descrição          :
     19          | 
     20          |       Autor              :
     21          |       Data criação       :
     22          |
     23          |       Revisões           :
     24          |
     25          |
     26          | __________________________________________________________________________________
     27          */
     28          
     29          /********************************************************************************
     30          *   Includes
     31          ********************************************************************************/
     32          #include <stdlib.h>
     33          #include <string.h>

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
     34          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     35            #include "FreeRTOS.h"
     36            #include "task.h"
     37          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     38          /********************************************************************************
     39          *   Definições
     40          ********************************************************************************/
     41          #define queueUNLOCKED				( ( signed portBASE_TYPE ) -1 )
     42          #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
     43          #define queueERRONEOUS_UNBLOCK			( -1 )
     44          #define	queueSEND_TO_BACK			( 0 )
     45          #define	queueSEND_TO_FRONT			( 1 )
     46          #define pxMutexHolder				pcTail
     47          #define uxQueueType				pcHead
     48          #define uxRecursiveCallCount			pcReadFrom
     49          #define queueQUEUE_IS_MUTEX			NULL
     50          #define queueSEMAPHORE_QUEUE_ITEM_LENGTH        ( 0 )
     51          #define queueDONT_BLOCK			        ( ( portTickType ) 0 )
     52          #define queueMUTEX_GIVE_BLOCK_TIME		( ( portTickType ) 0 )
     53          /********************************************************************************
     54          *   Estruturas
     55          ********************************************************************************/
     56          typedef struct QueueDefinition{
     57            signed char *pcHead;
     58            signed char *pcTail;
     59            signed char *pcWriteTo;
     60            signed char *pcReadFrom;
     61            xList xTasksWaitingToSend;
     62            xList xTasksWaitingToReceive;
     63            volatile unsigned portBASE_TYPE uxMessagesWaiting;
     64            unsigned portBASE_TYPE uxLength;		
     65            unsigned portBASE_TYPE uxItemSize;		
     66            signed portBASE_TYPE xRxLock;			
     67            signed portBASE_TYPE xTxLock;		
     68          } xQUEUE;
     69          
     70          typedef xQUEUE * xQueueHandle;
     71          
     72          typedef struct QUEUE_REGISTRY_ITEM
     73          {
     74            signed char *pcQueueName;
     75            xQueueHandle xHandle;
     76          } xQueueRegistryItem;
     77          
     78          /********************************************************************************
     79          *   Funções locais
     80          ********************************************************************************/
     81          xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize ) PRIVILEGED_FUNCTION;
     82          signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition ) PRIVILEGED_FUNCTION;
     83          unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
     84          void vQueueDelete( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
     85          signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition ) PRIVILEGED_FUNCTION;
     86          signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking ) PRIVILEGED_FUNCTION;
     87          signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken ) PRIVILEGED_FUNCTION;
     88          xQueueHandle xQueueCreateMutex( void ) PRIVILEGED_FUNCTION;
     89          xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount ) PRIVILEGED_FUNCTION;
     90          portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime ) PRIVILEGED_FUNCTION;
     91          portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex ) PRIVILEGED_FUNCTION;
     92          signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition ) PRIVILEGED_FUNCTION;
     93          signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking ) PRIVILEGED_FUNCTION;
     94          signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
     95          signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
     96          unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
     97          void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName ) PRIVILEGED_FUNCTION;
     98          static void vQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;;
     99          static void prvUnlockQueue( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
    100          static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
    101          static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
    102          static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition ) PRIVILEGED_FUNCTION;
    103          static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTION;

   \                                 In section .bss, align 4
    104          xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
   \                     xQueueRegistry:
   \   00000000                      DS8 80
    105          /********************************************************************************
    106          *   Macros
    107          ********************************************************************************/
    108          #define prvLockQueue( pxQueue )							\
    109          {														\
    110          	taskENTER_CRITICAL();								\
    111          	{													\
    112          		if( pxQueue->xRxLock == queueUNLOCKED )			\
    113          		{												\
    114          			pxQueue->xRxLock = queueLOCKED_UNMODIFIED;	\
    115          		}												\
    116          		if( pxQueue->xTxLock == queueUNLOCKED )			\
    117          		{												\
    118          			pxQueue->xTxLock = queueLOCKED_UNMODIFIED;	\
    119          		}												\
    120          	}													\
    121          	taskEXIT_CRITICAL();								\
    122          }
    123          /********************************************************************************
    124          *   Descrição   : 
    125          *   Parametros  : 
    126          *   Retorno     : 
    127          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    128          xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
    129          {
   \                     xQueueCreate:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    130            xQUEUE *pxNewQueue;
    131            size_t xQueueSizeInBytes; 
    132          
    133            if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD032             BEQ.N    ??xQueueCreate_0
    134            {
    135              pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
   \   0000000A   0x204C             MOVS     R0,#+76
   \   0000000C   0x.... 0x....      BL       pvPortMalloc
   \   00000010   0x0006             MOVS     R6,R0
    136              if( pxNewQueue != NULL )
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD02C             BEQ.N    ??xQueueCreate_0
    137              {
    138                xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
   \   00000016   0xFB05 0xF004      MUL      R0,R5,R4
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x0007             MOVS     R7,R0
    139                pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
   \   0000001E   0x0038             MOVS     R0,R7
   \   00000020   0x.... 0x....      BL       pvPortMalloc
   \   00000024   0x6030             STR      R0,[R6, #+0]
    140                if( pxNewQueue->pcHead != NULL )
   \   00000026   0x6830             LDR      R0,[R6, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD01E             BEQ.N    ??xQueueCreate_1
    141                { 
    142                  pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
   \   0000002C   0x6830             LDR      R0,[R6, #+0]
   \   0000002E   0xFB05 0x0004      MLA      R0,R5,R4,R0
   \   00000032   0x6070             STR      R0,[R6, #+4]
    143          	pxNewQueue->uxMessagesWaiting = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x63B0             STR      R0,[R6, #+56]
    144          	pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
   \   00000038   0x6830             LDR      R0,[R6, #+0]
   \   0000003A   0x60B0             STR      R0,[R6, #+8]
    145          	pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
   \   0000003C   0x1E60             SUBS     R0,R4,#+1
   \   0000003E   0x6831             LDR      R1,[R6, #+0]
   \   00000040   0xFB05 0x1000      MLA      R0,R5,R0,R1
   \   00000044   0x60F0             STR      R0,[R6, #+12]
    146          	pxNewQueue->uxLength = uxQueueLength;
   \   00000046   0x63F4             STR      R4,[R6, #+60]
    147          	pxNewQueue->uxItemSize = uxItemSize;
   \   00000048   0x6435             STR      R5,[R6, #+64]
    148          	pxNewQueue->xRxLock = queueUNLOCKED;
   \   0000004A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000004E   0x6470             STR      R0,[R6, #+68]
    149          	pxNewQueue->xTxLock = queueUNLOCKED;
   \   00000050   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000054   0x64B0             STR      R0,[R6, #+72]
    150          
    151          	vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
   \   00000056   0xF116 0x0010      ADDS     R0,R6,#+16
   \   0000005A   0x.... 0x....      BL       vListInitialise
    152          	vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
   \   0000005E   0xF116 0x0024      ADDS     R0,R6,#+36
   \   00000062   0x.... 0x....      BL       vListInitialise
    153          
    154          	traceQUEUE_CREATE( pxNewQueue );
    155          	return  pxNewQueue;
   \   00000066   0x0030             MOVS     R0,R6
   \   00000068   0xE003             B.N      ??xQueueCreate_2
    156                }
    157                else
    158                {
    159                    traceQUEUE_CREATE_FAILED();
    160          	  vPortFree( pxNewQueue );
   \                     ??xQueueCreate_1:
   \   0000006A   0x0030             MOVS     R0,R6
   \   0000006C   0x.... 0x....      BL       vPortFree
    161                } 
    162              }
    163            }
    164          
    165            return NULL;
   \                     ??xQueueCreate_0:
   \   00000070   0x2000             MOVS     R0,#+0
   \                     ??xQueueCreate_2:
   \   00000072   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    166          }
    167          /********************************************************************************
    168          *   Descrição     : 
    169          *   Parametros    : 
    170          *   Retorno       : 
    171          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    172          xQueueHandle xQueueCreateMutex( void )	{
   \                     xQueueCreateMutex:
   \   00000000   0xB510             PUSH     {R4,LR}
    173              xQUEUE *pxNewQueue;
    174          
    175              pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
   \   00000002   0x204C             MOVS     R0,#+76
   \   00000004   0x.... 0x....      BL       pvPortMalloc
   \   00000008   0x0004             MOVS     R4,R0
    176              if( pxNewQueue != NULL )
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD021             BEQ.N    ??xQueueCreateMutex_0
    177              {
    178                  pxNewQueue->pxMutexHolder = NULL;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x6060             STR      R0,[R4, #+4]
    179          	pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6020             STR      R0,[R4, #+0]
    180          
    181          	pxNewQueue->pcWriteTo = NULL;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x60A0             STR      R0,[R4, #+8]
    182          	pxNewQueue->pcReadFrom = NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x60E0             STR      R0,[R4, #+12]
    183          
    184          	pxNewQueue->uxMessagesWaiting = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x63A0             STR      R0,[R4, #+56]
    185          	pxNewQueue->uxLength = 1;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x63E0             STR      R0,[R4, #+60]
    186          	pxNewQueue->uxItemSize = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x6420             STR      R0,[R4, #+64]
    187          	pxNewQueue->xRxLock = queueUNLOCKED;
   \   0000002A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000002E   0x6460             STR      R0,[R4, #+68]
    188          	pxNewQueue->xTxLock = queueUNLOCKED;
   \   00000030   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000034   0x64A0             STR      R0,[R4, #+72]
    189                  
    190          	vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
   \   00000036   0xF114 0x0010      ADDS     R0,R4,#+16
   \   0000003A   0x.... 0x....      BL       vListInitialise
    191          	vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
   \   0000003E   0xF114 0x0024      ADDS     R0,R4,#+36
   \   00000042   0x.... 0x....      BL       vListInitialise
    192          
    193          	xQueueGenericSend( pxNewQueue, NULL, 0, queueSEND_TO_BACK );
   \   00000046   0x2300             MOVS     R3,#+0
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       xQueueGenericSend
    194          
    195          	traceCREATE_MUTEX( pxNewQueue );
    196              }
    197              else
    198              {
    199          	traceCREATE_MUTEX_FAILED();
    200              }
    201          
    202              return pxNewQueue;
   \                     ??xQueueCreateMutex_0:
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
    203          }
    204          /********************************************************************************
    205          *   Descrição     :   
    206          *   Parametros    : 
    207          *   Retorno       : 
    208          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    209          portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
    210          {
   \                     xQueueGiveMutexRecursive:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    211              portBASE_TYPE xReturn;
    212          
    213              if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
   \   00000004   0x6866             LDR      R6,[R4, #+4]
   \   00000006   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \   0000000A   0x4286             CMP      R6,R0
   \   0000000C   0xD10E             BNE.N    ??xQueueGiveMutexRecursive_0
    214              {
    215          	traceGIVE_MUTEX_RECURSIVE( pxMutex );
    216          
    217          	( pxMutex->uxRecursiveCallCount )--;
   \   0000000E   0x68E0             LDR      R0,[R4, #+12]
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0x60E0             STR      R0,[R4, #+12]
    218          	if( pxMutex->uxRecursiveCallCount == 0 )
   \   00000014   0x68E0             LDR      R0,[R4, #+12]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD105             BNE.N    ??xQueueGiveMutexRecursive_1
    219          	{
    220          	    xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       xQueueGenericSend
    221          	}
    222          	xReturn = pdPASS;
   \                     ??xQueueGiveMutexRecursive_1:
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x0005             MOVS     R5,R0
   \   0000002A   0xE001             B.N      ??xQueueGiveMutexRecursive_2
    223              }
    224              else
    225              {
    226          	xReturn = pdFAIL;
   \                     ??xQueueGiveMutexRecursive_0:
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x0005             MOVS     R5,R0
    227          
    228          	traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
    229              }
    230              return xReturn;
   \                     ??xQueueGiveMutexRecursive_2:
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    231          }
    232          /********************************************************************************
    233          *   Descrição   :
    234          *   Parametros  : 
    235          *   Retorno     : 
    236          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    237          portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
    238          {
   \                     xQueueTakeMutexRecursive:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    239              portBASE_TYPE xReturn;
    240          
    241              traceTAKE_MUTEX_RECURSIVE( pxMutex );
    242          
    243              if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
   \   00000006   0x6867             LDR      R7,[R4, #+4]
   \   00000008   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \   0000000C   0x4287             CMP      R7,R0
   \   0000000E   0xD105             BNE.N    ??xQueueTakeMutexRecursive_0
    244              {
    245          	  ( pxMutex->uxRecursiveCallCount )++;
   \   00000010   0x68E0             LDR      R0,[R4, #+12]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x60E0             STR      R0,[R4, #+12]
    246          	    xReturn = pdPASS;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x0006             MOVS     R6,R0
   \   0000001A   0xE00B             B.N      ??xQueueTakeMutexRecursive_1
    247              }
    248              else
    249              {
    250          	xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
   \                     ??xQueueTakeMutexRecursive_0:
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x002A             MOVS     R2,R5
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       xQueueGenericReceive
   \   00000028   0x0006             MOVS     R6,R0
    251          
    252                  if( xReturn == pdPASS )
   \   0000002A   0x2E01             CMP      R6,#+1
   \   0000002C   0xD102             BNE.N    ??xQueueTakeMutexRecursive_1
    253          	{
    254          	  ( pxMutex->uxRecursiveCallCount )++;
   \   0000002E   0x68E0             LDR      R0,[R4, #+12]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x60E0             STR      R0,[R4, #+12]
    255          	}
    256          	else
    257          	{
    258          	  traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
    259          	}
    260              }
    261          
    262              return xReturn;
   \                     ??xQueueTakeMutexRecursive_1:
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    263          }
    264          /********************************************************************************
    265          *   Descrição     :   
    266          *   Parametros    : 
    267          *   Retorno       : 
    268          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    269          signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
    270          {
   \                     xQueueGenericSend:
   \   00000000   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x001E             MOVS     R6,R3
    271            signed portBASE_TYPE xEntryTimeSet = pdFALSE;
   \   00000008   0x2700             MOVS     R7,#+0
    272            xTimeOutType xTimeOut;
    273          
    274            for( ;; )
    275            {
    276                taskENTER_CRITICAL();
   \                     ??xQueueGenericSend_0:
   \   0000000A   0x.... 0x....      BL       vPortEnterCritical
    277                {
    278          	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   \   0000000E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000010   0x6BE1             LDR      R1,[R4, #+60]
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD213             BCS.N    ??xQueueGenericSend_1
    279          	{
    280          	    traceQUEUE_SEND( pxQueue );
    281          	    prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   \   00000016   0x0032             MOVS     R2,R6
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       prvCopyDataToQueue
    282          
    283          	    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   \   00000020   0x6A60             LDR      R0,[R4, #+36]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD007             BEQ.N    ??xQueueGenericSend_2
    284          	    {
    285          		if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
   \   00000026   0xF114 0x0024      ADDS     R0,R4,#+36
   \   0000002A   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD101             BNE.N    ??xQueueGenericSend_2
    286          		{
    287          		    portYIELD_WITHIN_API();
   \   00000032   0x.... 0x....      BL       vPortYieldFromISR
    288          		}
    289          	    }
    290          
    291                      taskEXIT_CRITICAL();
   \                     ??xQueueGenericSend_2:
   \   00000036   0x.... 0x....      BL       vPortExitCritical
    292          
    293          	return pdPASS;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xE048             B.N      ??xQueueGenericSend_3
    294             }
    295              else
    296              {
    297          	if( xTicksToWait == ( portTickType ) 0 )
   \                     ??xQueueGenericSend_1:
   \   0000003E   0x9802             LDR      R0,[SP, #+8]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD103             BNE.N    ??xQueueGenericSend_4
    298          	 {
    299          	    taskEXIT_CRITICAL();
   \   00000044   0x.... 0x....      BL       vPortExitCritical
    300          
    301          	    traceQUEUE_SEND_FAILED( pxQueue );
    302          	    return errQUEUE_FULL;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE041             B.N      ??xQueueGenericSend_3
    303          	  }
    304          	else if( xEntryTimeSet == pdFALSE )
   \                     ??xQueueGenericSend_4:
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xD104             BNE.N    ??xQueueGenericSend_5
    305          	{
    306          	    vTaskSetTimeOutState( &xTimeOut );
   \   00000050   0xA800             ADD      R0,SP,#+0
   \   00000052   0x.... 0x....      BL       vTaskSetTimeOutState
    307          	    xEntryTimeSet = pdTRUE;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x0007             MOVS     R7,R0
    308          	}
    309              }
    310            }
    311            taskEXIT_CRITICAL();
   \                     ??xQueueGenericSend_5:
   \   0000005A   0x.... 0x....      BL       vPortExitCritical
    312          
    313             vTaskSuspendAll();
   \   0000005E   0x.... 0x....      BL       vTaskSuspendAll
    314             prvLockQueue( pxQueue );
   \   00000062   0x.... 0x....      BL       vPortEnterCritical
   \   00000066   0x6C60             LDR      R0,[R4, #+68]
   \   00000068   0xF110 0x0F01      CMN      R0,#+1
   \   0000006C   0xD101             BNE.N    ??xQueueGenericSend_6
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x6460             STR      R0,[R4, #+68]
   \                     ??xQueueGenericSend_6:
   \   00000072   0x6CA0             LDR      R0,[R4, #+72]
   \   00000074   0xF110 0x0F01      CMN      R0,#+1
   \   00000078   0xD101             BNE.N    ??xQueueGenericSend_7
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x64A0             STR      R0,[R4, #+72]
   \                     ??xQueueGenericSend_7:
   \   0000007E   0x.... 0x....      BL       vPortExitCritical
    315          
    316              if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   \   00000082   0xA902             ADD      R1,SP,#+8
   \   00000084   0xA800             ADD      R0,SP,#+0
   \   00000086   0x.... 0x....      BL       xTaskCheckForTimeOut
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD119             BNE.N    ??xQueueGenericSend_8
    317              {
    318          	if( prvIsQueueFull( pxQueue ) )
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       prvIsQueueFull
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD00E             BEQ.N    ??xQueueGenericSend_9
    319          	{
    320          	    traceBLOCKING_ON_QUEUE_SEND( pxQueue );
    321          	    vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   \   00000098   0x9902             LDR      R1,[SP, #+8]
   \   0000009A   0xF114 0x0010      ADDS     R0,R4,#+16
   \   0000009E   0x.... 0x....      BL       vTaskPlaceOnEventList
    322                	    prvUnlockQueue( pxQueue );
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x.... 0x....      BL       prvUnlockQueue
    323              	    if( !xTaskResumeAll() )
   \   000000A8   0x.... 0x....      BL       xTaskResumeAll
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD1AC             BNE.N    ??xQueueGenericSend_0
    324          	    {
    325          		portYIELD_WITHIN_API();
   \   000000B0   0x.... 0x....      BL       vPortYieldFromISR
   \   000000B4   0xE7A9             B.N      ??xQueueGenericSend_0
    326          	    }
    327          	}
    328          	else
    329          	{
    330          	    prvUnlockQueue( pxQueue );
   \                     ??xQueueGenericSend_9:
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       prvUnlockQueue
    331          	    ( void ) xTaskResumeAll();
   \   000000BC   0x.... 0x....      BL       xTaskResumeAll
   \   000000C0   0xE7A3             B.N      ??xQueueGenericSend_0
    332          	}
    333              }
    334              else
    335              {
    336          	prvUnlockQueue( pxQueue );
   \                     ??xQueueGenericSend_8:
   \   000000C2   0x0020             MOVS     R0,R4
   \   000000C4   0x.... 0x....      BL       prvUnlockQueue
    337          	( void ) xTaskResumeAll();
   \   000000C8   0x.... 0x....      BL       xTaskResumeAll
   \   000000CC   0x0001             MOVS     R1,R0
    338                  traceQUEUE_SEND_FAILED( pxQueue );
    339          	return errQUEUE_FULL;
   \   000000CE   0x2000             MOVS     R0,#+0
   \                     ??xQueueGenericSend_3:
   \   000000D0   0xBDFE             POP      {R1-R7,PC}       ;; return
    340              }
    341            }
    342          }
    343          /********************************************************************************
    344          *     Descrição     : 
    345          *     Parametros    : 
    346          *     Retorno       : 
    347          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    348          signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
    349          {
   \                     xQueueGenericSendFromISR:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    350            signed portBASE_TYPE xReturn;
    351            unsigned portBASE_TYPE uxSavedInterruptStatus;
    352            
    353              uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4681             MOV      R9,R0
   \   00000010   0x.... 0x....      BL       vPortSetInterruptMask
    354              {
    355                  if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   \   00000014   0x6BA0             LDR      R0,[R4, #+56]
   \   00000016   0x6BE1             LDR      R1,[R4, #+60]
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD21A             BCS.N    ??xQueueGenericSendFromISR_0
    356          	{
    357          	    traceQUEUE_SEND_FROM_ISR( pxQueue );
    358          	    prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   \   0000001C   0x003A             MOVS     R2,R7
   \   0000001E   0x0029             MOVS     R1,R5
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       prvCopyDataToQueue
    359          
    360          	    if( pxQueue->xTxLock == queueUNLOCKED )
   \   00000026   0x6CA0             LDR      R0,[R4, #+72]
   \   00000028   0xF110 0x0F01      CMN      R0,#+1
   \   0000002C   0xD10B             BNE.N    ??xQueueGenericSendFromISR_1
    361          	    {
    362          		if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
   \   0000002E   0x6A60             LDR      R0,[R4, #+36]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD00B             BEQ.N    ??xQueueGenericSendFromISR_2
    363          		{
    364                		  if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \   00000034   0xF114 0x0024      ADDS     R0,R4,#+36
   \   00000038   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD005             BEQ.N    ??xQueueGenericSendFromISR_2
    365          		  {
    366          			*pxHigherPriorityTaskWoken = pdTRUE;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x6030             STR      R0,[R6, #+0]
   \   00000044   0xE002             B.N      ??xQueueGenericSendFromISR_2
    367          		  }
    368          		 }
    369          	    }
    370              else
    371              {
    372          	++( pxQueue->xTxLock );
   \                     ??xQueueGenericSendFromISR_1:
   \   00000046   0x6CA0             LDR      R0,[R4, #+72]
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \   0000004A   0x64A0             STR      R0,[R4, #+72]
    373              }
    374          
    375              xReturn = pdPASS;
   \                     ??xQueueGenericSendFromISR_2:
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x4680             MOV      R8,R0
   \   00000050   0xE001             B.N      ??xQueueGenericSendFromISR_3
    376              }
    377              else
    378              {
    379          	traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
    380          	xReturn = errQUEUE_FULL;
   \                     ??xQueueGenericSendFromISR_0:
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x4680             MOV      R8,R0
    381              }
    382              }
    383              portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueGenericSendFromISR_3:
   \   00000056   0x.... 0x....      BL       vPortClearInterruptMask
    384          
    385              return xReturn;
   \   0000005A   0x4640             MOV      R0,R8
   \   0000005C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    386          }
    387          /********************************************************************************
    388          *   Descrição   : 
    389          *   Parametros  : 
    390          *   Retorno     : 
    391          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    392          signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
    393          {
   \                     xQueueGenericReceive:
   \   00000000   0xE92D 0x41F4      PUSH     {R2,R4-R8,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x001E             MOVS     R6,R3
    394          signed portBASE_TYPE xEntryTimeSet = pdFALSE;
   \   0000000C   0x2700             MOVS     R7,#+0
    395          xTimeOutType xTimeOut;
    396          signed char *pcOriginalReadPosition;
    397          
    398          	for( ;; )
    399          	{
    400          		taskENTER_CRITICAL();
   \                     ??xQueueGenericReceive_0:
   \   0000000E   0x.... 0x....      BL       vPortEnterCritical
    401          		{
    402          			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
   \   00000012   0x6BA0             LDR      R0,[R4, #+56]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD02D             BEQ.N    ??xQueueGenericReceive_1
    403          			{
    404          				pcOriginalReadPosition = pxQueue->pcReadFrom;
   \   00000018   0x68E0             LDR      R0,[R4, #+12]
   \   0000001A   0x4680             MOV      R8,R0
    405          
    406          				prvCopyDataFromQueue( pxQueue, pvBuffer );
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       prvCopyDataFromQueue
    407          
    408          				if( xJustPeeking == pdFALSE )
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD114             BNE.N    ??xQueueGenericReceive_2
    409          				{
    410          					traceQUEUE_RECEIVE( pxQueue );
    411          
    412          					--( pxQueue->uxMessagesWaiting );
   \   00000028   0x6BA0             LDR      R0,[R4, #+56]
   \   0000002A   0x1E40             SUBS     R0,R0,#+1
   \   0000002C   0x63A0             STR      R0,[R4, #+56]
    413          
    414          					{
    415          						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD102             BNE.N    ??xQueueGenericReceive_3
    416          						{
    417          							/* Record the information required to implement
    418          							priority inheritance should it become necessary. */
    419          							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
   \   00000034   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \   00000038   0x6060             STR      R0,[R4, #+4]
    420          						}
    421          					}
    422          
    423          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   \                     ??xQueueGenericReceive_3:
   \   0000003A   0x6920             LDR      R0,[R4, #+16]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD015             BEQ.N    ??xQueueGenericReceive_4
    424          					{
    425          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   \   00000040   0xF114 0x0010      ADDS     R0,R4,#+16
   \   00000044   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD10F             BNE.N    ??xQueueGenericReceive_4
    426          						{
    427          							portYIELD_WITHIN_API();
   \   0000004C   0x.... 0x....      BL       vPortYieldFromISR
   \   00000050   0xE00C             B.N      ??xQueueGenericReceive_4
    428          						}
    429          					}
    430          				}
    431          				else
    432          				{
    433          					traceQUEUE_PEEK( pxQueue );
    434          
    435          					pxQueue->pcReadFrom = pcOriginalReadPosition;
   \                     ??xQueueGenericReceive_2:
   \   00000052   0xF8C4 0x800C      STR      R8,[R4, #+12]
    436          
    437          					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
   \   00000056   0x6A60             LDR      R0,[R4, #+36]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD007             BEQ.N    ??xQueueGenericReceive_4
    438          					{
    439          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \   0000005C   0xF114 0x0024      ADDS     R0,R4,#+36
   \   00000060   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD001             BEQ.N    ??xQueueGenericReceive_4
    440          						{
    441          							portYIELD_WITHIN_API();
   \   00000068   0x.... 0x....      BL       vPortYieldFromISR
    442          						}
    443          					}
    444          
    445          				}
    446          
    447          				taskEXIT_CRITICAL();
   \                     ??xQueueGenericReceive_4:
   \   0000006C   0x.... 0x....      BL       vPortExitCritical
    448          				return pdPASS;
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xE052             B.N      ??xQueueGenericReceive_5
    449          			}
    450          			else
    451          			{
    452          				if( xTicksToWait == ( portTickType ) 0 )
   \                     ??xQueueGenericReceive_1:
   \   00000074   0x9803             LDR      R0,[SP, #+12]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD103             BNE.N    ??xQueueGenericReceive_6
    453          				{
    454          					taskEXIT_CRITICAL();
   \   0000007A   0x.... 0x....      BL       vPortExitCritical
    455          					traceQUEUE_RECEIVE_FAILED( pxQueue );
    456          					return errQUEUE_EMPTY;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE04B             B.N      ??xQueueGenericReceive_5
    457          				}
    458          				else if( xEntryTimeSet == pdFALSE )
   \                     ??xQueueGenericReceive_6:
   \   00000082   0x2F00             CMP      R7,#+0
   \   00000084   0xD104             BNE.N    ??xQueueGenericReceive_7
    459          				{
    460          					vTaskSetTimeOutState( &xTimeOut );
   \   00000086   0xA800             ADD      R0,SP,#+0
   \   00000088   0x.... 0x....      BL       vTaskSetTimeOutState
    461          					xEntryTimeSet = pdTRUE;
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x0007             MOVS     R7,R0
    462          				}
    463          			}
    464          		}
    465          		taskEXIT_CRITICAL();
   \                     ??xQueueGenericReceive_7:
   \   00000090   0x.... 0x....      BL       vPortExitCritical
    466          
    467          		vTaskSuspendAll();
   \   00000094   0x.... 0x....      BL       vTaskSuspendAll
    468          		prvLockQueue( pxQueue );
   \   00000098   0x.... 0x....      BL       vPortEnterCritical
   \   0000009C   0x6C60             LDR      R0,[R4, #+68]
   \   0000009E   0xF110 0x0F01      CMN      R0,#+1
   \   000000A2   0xD101             BNE.N    ??xQueueGenericReceive_8
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x6460             STR      R0,[R4, #+68]
   \                     ??xQueueGenericReceive_8:
   \   000000A8   0x6CA0             LDR      R0,[R4, #+72]
   \   000000AA   0xF110 0x0F01      CMN      R0,#+1
   \   000000AE   0xD101             BNE.N    ??xQueueGenericReceive_9
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x64A0             STR      R0,[R4, #+72]
   \                     ??xQueueGenericReceive_9:
   \   000000B4   0x.... 0x....      BL       vPortExitCritical
    469          
    470          		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   \   000000B8   0xA903             ADD      R1,SP,#+12
   \   000000BA   0xA800             ADD      R0,SP,#+0
   \   000000BC   0x.... 0x....      BL       xTaskCheckForTimeOut
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD123             BNE.N    ??xQueueGenericReceive_10
    471          		{
    472          			if( prvIsQueueEmpty( pxQueue ) )
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x.... 0x....      BL       prvIsQueueEmpty
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD018             BEQ.N    ??xQueueGenericReceive_11
    473          			{
    474          				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
    475          
    476          				{
    477          					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD106             BNE.N    ??xQueueGenericReceive_12
    478          					{
    479          						portENTER_CRITICAL();
   \   000000D4   0x.... 0x....      BL       vPortEnterCritical
    480          						{
    481          							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
   \   000000D8   0x6860             LDR      R0,[R4, #+4]
   \   000000DA   0x.... 0x....      BL       vTaskPriorityInherit
    482          						}
    483          						portEXIT_CRITICAL();
   \   000000DE   0x.... 0x....      BL       vPortExitCritical
    484          					}
    485          				}
    486          
    487          				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   \                     ??xQueueGenericReceive_12:
   \   000000E2   0x9903             LDR      R1,[SP, #+12]
   \   000000E4   0xF114 0x0024      ADDS     R0,R4,#+36
   \   000000E8   0x.... 0x....      BL       vTaskPlaceOnEventList
    488          				prvUnlockQueue( pxQueue );
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       prvUnlockQueue
    489          				if( !xTaskResumeAll() )
   \   000000F2   0x.... 0x....      BL       xTaskResumeAll
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD189             BNE.N    ??xQueueGenericReceive_0
    490          				{
    491          					portYIELD_WITHIN_API();
   \   000000FA   0x.... 0x....      BL       vPortYieldFromISR
   \   000000FE   0xE786             B.N      ??xQueueGenericReceive_0
    492          				}
    493          			}
    494          			else
    495          			{
    496          				prvUnlockQueue( pxQueue );
   \                     ??xQueueGenericReceive_11:
   \   00000100   0x0020             MOVS     R0,R4
   \   00000102   0x.... 0x....      BL       prvUnlockQueue
    497          				( void ) xTaskResumeAll();
   \   00000106   0x.... 0x....      BL       xTaskResumeAll
   \   0000010A   0xE780             B.N      ??xQueueGenericReceive_0
    498          			}
    499          		}
    500          		else
    501          		{
    502          			prvUnlockQueue( pxQueue );
   \                     ??xQueueGenericReceive_10:
   \   0000010C   0x0020             MOVS     R0,R4
   \   0000010E   0x.... 0x....      BL       prvUnlockQueue
    503          			( void ) xTaskResumeAll();
   \   00000112   0x.... 0x....      BL       xTaskResumeAll
   \   00000116   0x0001             MOVS     R1,R0
    504          			traceQUEUE_RECEIVE_FAILED( pxQueue );
    505          			return errQUEUE_EMPTY;
   \   00000118   0x2000             MOVS     R0,#+0
   \                     ??xQueueGenericReceive_5:
   \   0000011A   0xB004             ADD      SP,SP,#+16
   \   0000011C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    506          		}
    507          	}
    508          }
    509          /********************************************************************************
    510          *   Descrição     :
    511          *   Parametros    : 
    512          *   Retorno       : 
    513          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    514          signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
    515          {
   \                     xQueueReceiveFromISR:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    516          signed portBASE_TYPE xReturn;
    517          unsigned portBASE_TYPE uxSavedInterruptStatus;
    518          
    519          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4680             MOV      R8,R0
   \   0000000E   0x.... 0x....      BL       vPortSetInterruptMask
    520          	{
    521          		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
   \   00000012   0x6BA0             LDR      R0,[R4, #+56]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD01C             BEQ.N    ??xQueueReceiveFromISR_0
    522          		{
    523          			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
    524          
    525          			prvCopyDataFromQueue( pxQueue, pvBuffer );
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       prvCopyDataFromQueue
    526          			--( pxQueue->uxMessagesWaiting );
   \   00000020   0x6BA0             LDR      R0,[R4, #+56]
   \   00000022   0x1E40             SUBS     R0,R0,#+1
   \   00000024   0x63A0             STR      R0,[R4, #+56]
    527          			if( pxQueue->xRxLock == queueUNLOCKED )
   \   00000026   0x6C60             LDR      R0,[R4, #+68]
   \   00000028   0xF110 0x0F01      CMN      R0,#+1
   \   0000002C   0xD10B             BNE.N    ??xQueueReceiveFromISR_1
    528          			{
    529          				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
   \   0000002E   0x6920             LDR      R0,[R4, #+16]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD00B             BEQ.N    ??xQueueReceiveFromISR_2
    530          				{
    531          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   \   00000034   0xF114 0x0010      ADDS     R0,R4,#+16
   \   00000038   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD005             BEQ.N    ??xQueueReceiveFromISR_2
    532          					{
    533          						*pxTaskWoken = pdTRUE;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x6030             STR      R0,[R6, #+0]
   \   00000044   0xE002             B.N      ??xQueueReceiveFromISR_2
    534          					}
    535          				}
    536          			}
    537          			else
    538          			{
    539          				++( pxQueue->xRxLock );
   \                     ??xQueueReceiveFromISR_1:
   \   00000046   0x6C60             LDR      R0,[R4, #+68]
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \   0000004A   0x6460             STR      R0,[R4, #+68]
    540          			}
    541          
    542          			xReturn = pdPASS;
   \                     ??xQueueReceiveFromISR_2:
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x0007             MOVS     R7,R0
   \   00000050   0xE001             B.N      ??xQueueReceiveFromISR_3
    543          		}
    544          		else
    545          		{
    546          			xReturn = pdFAIL;
   \                     ??xQueueReceiveFromISR_0:
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x0007             MOVS     R7,R0
    547          			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
    548          		}
    549          	}
    550          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueReceiveFromISR_3:
   \   00000056   0x.... 0x....      BL       vPortClearInterruptMask
    551          
    552          	return xReturn;
   \   0000005A   0x0038             MOVS     R0,R7
   \   0000005C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    553          }
    554          /********************************************************************************
    555          *     Descrição     :   
    556          *     Parametros    : 
    557          *     Retorno       : 
    558          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    559          unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
    560          {
   \                     uxQueueMessagesWaiting:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    561          unsigned portBASE_TYPE uxReturn;
    562          
    563          	taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
    564          		uxReturn = pxQueue->uxMessagesWaiting;
   \   00000008   0x6BA0             LDR      R0,[R4, #+56]
   \   0000000A   0x0005             MOVS     R5,R0
    565          	taskEXIT_CRITICAL();
   \   0000000C   0x.... 0x....      BL       vPortExitCritical
    566          
    567          	return uxReturn;
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    568          }
    569          /********************************************************************************
    570          *   Descrição      :  
    571          *   Parametros     :
    572          *   Retorno        :  
    573          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    574          unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
    575          {
   \                     uxQueueMessagesWaitingFromISR:
   \   00000000   0x0001             MOVS     R1,R0
    576          unsigned portBASE_TYPE uxReturn;
    577          
    578          	uxReturn = pxQueue->uxMessagesWaiting;
   \   00000002   0x6B8A             LDR      R2,[R1, #+56]
   \   00000004   0x0010             MOVS     R0,R2
    579          
    580          	return uxReturn;
   \   00000006   0x4770             BX       LR               ;; return
    581          }
    582          /********************************************************************************
    583          *   Descrição      :  
    584          *   Parametros     :
    585          *   Retorno        :  
    586          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    587          void vQueueDelete( xQueueHandle pxQueue )
    588          {
   \                     vQueueDelete:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    589          	traceQUEUE_DELETE( pxQueue );
    590          	vQueueUnregisterQueue( pxQueue );
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       vQueueUnregisterQueue
    591          	vPortFree( pxQueue->pcHead );
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       vPortFree
    592          	vPortFree( pxQueue );
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       vPortFree
    593          }
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    594          /********************************************************************************
    595          *   Descrição      :  
    596          *   Parametros     :
    597          *   Retorno        :  
    598          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    599          static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
    600          {
   \                     prvCopyDataToQueue:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    601          	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
   \   00000008   0x6C20             LDR      R0,[R4, #+64]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD108             BNE.N    ??prvCopyDataToQueue_0
    602          	{
    603          		{
    604          			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD12A             BNE.N    ??prvCopyDataToQueue_1
    605          			{
    606          				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
   \   00000014   0x6860             LDR      R0,[R4, #+4]
   \   00000016   0x.... 0x....      BL       vTaskPriorityDisinherit
    607          				pxQueue->pxMutexHolder = NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x6060             STR      R0,[R4, #+4]
   \   0000001E   0xE024             B.N      ??prvCopyDataToQueue_1
    608          			}
    609          		}
    610          	}
    611          	else if( xPosition == queueSEND_TO_BACK )
   \                     ??prvCopyDataToQueue_0:
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD10F             BNE.N    ??prvCopyDataToQueue_2
    612          	{
    613          		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
   \   00000024   0x6C22             LDR      R2,[R4, #+64]
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0x68A0             LDR      R0,[R4, #+8]
   \   0000002A   0x.... 0x....      BL       memcpy
    614          		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   \   0000002E   0x6C20             LDR      R0,[R4, #+64]
   \   00000030   0x68A1             LDR      R1,[R4, #+8]
   \   00000032   0x1840             ADDS     R0,R0,R1
   \   00000034   0x60A0             STR      R0,[R4, #+8]
    615          		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
   \   00000036   0x68A0             LDR      R0,[R4, #+8]
   \   00000038   0x6861             LDR      R1,[R4, #+4]
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD315             BCC.N    ??prvCopyDataToQueue_1
    616          		{
    617          			pxQueue->pcWriteTo = pxQueue->pcHead;
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x60A0             STR      R0,[R4, #+8]
   \   00000042   0xE012             B.N      ??prvCopyDataToQueue_1
    618          		}
    619          	}
    620          	else
    621          	{
    622          		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
   \                     ??prvCopyDataToQueue_2:
   \   00000044   0x6C22             LDR      R2,[R4, #+64]
   \   00000046   0x0029             MOVS     R1,R5
   \   00000048   0x68E0             LDR      R0,[R4, #+12]
   \   0000004A   0x.... 0x....      BL       memcpy
    623          		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
   \   0000004E   0x6C20             LDR      R0,[R4, #+64]
   \   00000050   0x4240             RSBS     R0,R0,#+0
   \   00000052   0x68E1             LDR      R1,[R4, #+12]
   \   00000054   0x1840             ADDS     R0,R0,R1
   \   00000056   0x60E0             STR      R0,[R4, #+12]
    624          		if( pxQueue->pcReadFrom < pxQueue->pcHead )
   \   00000058   0x68E0             LDR      R0,[R4, #+12]
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD204             BCS.N    ??prvCopyDataToQueue_1
    625          		{
    626          			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   \   00000060   0x6C20             LDR      R0,[R4, #+64]
   \   00000062   0x4240             RSBS     R0,R0,#+0
   \   00000064   0x6861             LDR      R1,[R4, #+4]
   \   00000066   0x1840             ADDS     R0,R0,R1
   \   00000068   0x60E0             STR      R0,[R4, #+12]
    627          		}
    628          	}
    629          
    630          	++( pxQueue->uxMessagesWaiting );
   \                     ??prvCopyDataToQueue_1:
   \   0000006A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000006C   0x1C40             ADDS     R0,R0,#+1
   \   0000006E   0x63A0             STR      R0,[R4, #+56]
    631          }
   \   00000070   0xBD70             POP      {R4-R6,PC}       ;; return
    632          /********************************************************************************
    633          *   Descrição      :  
    634          *   Parametros     :
    635          *   Retorno        :  
    636          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    637          static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
    638          {
   \                     prvCopyDataFromQueue:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    639          	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00E             BEQ.N    ??prvCopyDataFromQueue_0
    640          	{
    641          		pxQueue->pcReadFrom += pxQueue->uxItemSize;
   \   0000000C   0x6C20             LDR      R0,[R4, #+64]
   \   0000000E   0x68E1             LDR      R1,[R4, #+12]
   \   00000010   0x1840             ADDS     R0,R0,R1
   \   00000012   0x60E0             STR      R0,[R4, #+12]
    642          		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
   \   00000014   0x68E0             LDR      R0,[R4, #+12]
   \   00000016   0x6861             LDR      R1,[R4, #+4]
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD301             BCC.N    ??prvCopyDataFromQueue_1
    643          		{
    644          			pxQueue->pcReadFrom = pxQueue->pcHead;
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x60E0             STR      R0,[R4, #+12]
    645          		}
    646          		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   \                     ??prvCopyDataFromQueue_1:
   \   00000020   0x6C22             LDR      R2,[R4, #+64]
   \   00000022   0x68E1             LDR      R1,[R4, #+12]
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0x.... 0x....      BL       memcpy
    647          	}
    648          }
   \                     ??prvCopyDataFromQueue_0:
   \   0000002A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    649          /********************************************************************************
    650          *   Descrição      :  
    651          *   Parametros     :
    652          *   Retorno        :  
    653          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    654          static void prvUnlockQueue( xQueueHandle pxQueue )
    655          {
   \                     prvUnlockQueue:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    656          	taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
    657          	{
    658          		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
   \                     ??prvUnlockQueue_0:
   \   00000008   0x6CA0             LDR      R0,[R4, #+72]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xDB0E             BLT.N    ??prvUnlockQueue_1
    659          		{
    660          			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
   \   0000000E   0x6A60             LDR      R0,[R4, #+36]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD00B             BEQ.N    ??prvUnlockQueue_2
    661          			{
    662          				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \   00000014   0xF114 0x0024      ADDS     R0,R4,#+36
   \   00000018   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??prvUnlockQueue_3
    663          				{
    664          					vTaskMissedYield();
   \   00000020   0x.... 0x....      BL       vTaskMissedYield
    665          				}
    666          
    667          				--( pxQueue->xTxLock );
   \                     ??prvUnlockQueue_3:
   \   00000024   0x6CA0             LDR      R0,[R4, #+72]
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0x64A0             STR      R0,[R4, #+72]
   \   0000002A   0xE7ED             B.N      ??prvUnlockQueue_0
    668          			}
    669          			else
    670          			{
    671          				break;
    672          			}
    673          		}
    674          
    675          		pxQueue->xTxLock = queueUNLOCKED;
   \                     ??prvUnlockQueue_2:
   \                     ??prvUnlockQueue_1:
   \   0000002C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000030   0x64A0             STR      R0,[R4, #+72]
    676          	}
    677          	taskEXIT_CRITICAL();
   \   00000032   0x.... 0x....      BL       vPortExitCritical
    678          
    679          	taskENTER_CRITICAL();
   \   00000036   0x.... 0x....      BL       vPortEnterCritical
    680          	{
    681          		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
   \                     ??prvUnlockQueue_4:
   \   0000003A   0x6C60             LDR      R0,[R4, #+68]
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xDB0E             BLT.N    ??prvUnlockQueue_5
    682          		{
    683          			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
   \   00000040   0x6920             LDR      R0,[R4, #+16]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD00B             BEQ.N    ??prvUnlockQueue_6
    684          			{
    685          				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   \   00000046   0xF114 0x0010      ADDS     R0,R4,#+16
   \   0000004A   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD001             BEQ.N    ??prvUnlockQueue_7
    686          				{
    687          					vTaskMissedYield();
   \   00000052   0x.... 0x....      BL       vTaskMissedYield
    688          				}
    689          
    690          				--( pxQueue->xRxLock );
   \                     ??prvUnlockQueue_7:
   \   00000056   0x6C60             LDR      R0,[R4, #+68]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x6460             STR      R0,[R4, #+68]
   \   0000005C   0xE7ED             B.N      ??prvUnlockQueue_4
    691          			}
    692          			else
    693          			{
    694          				break;
    695          			}
    696          		}
    697          
    698          		pxQueue->xRxLock = queueUNLOCKED;
   \                     ??prvUnlockQueue_6:
   \                     ??prvUnlockQueue_5:
   \   0000005E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000062   0x6460             STR      R0,[R4, #+68]
    699          	}
    700          	taskEXIT_CRITICAL();
   \   00000064   0x.... 0x....      BL       vPortExitCritical
    701          }
   \   00000068   0xBD10             POP      {R4,PC}          ;; return
    702          /********************************************************************************
    703          *   Descrição      :  
    704          *   Parametros     :
    705          *   Retorno        :  
    706          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    707          static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
    708          {
   \                     prvIsQueueEmpty:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    709          signed portBASE_TYPE xReturn;
    710          
    711          	taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
    712          		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
   \   00000008   0x6BA0             LDR      R0,[R4, #+56]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??prvIsQueueEmpty_0
   \   0000000E   0x2501             MOVS     R5,#+1
   \   00000010   0xE000             B.N      ??prvIsQueueEmpty_1
   \                     ??prvIsQueueEmpty_0:
   \   00000012   0x2500             MOVS     R5,#+0
   \                     ??prvIsQueueEmpty_1:
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
    713          	taskEXIT_CRITICAL();
   \   00000016   0x.... 0x....      BL       vPortExitCritical
    714          
    715          	return xReturn;
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    716          }
    717          /********************************************************************************
    718          *   Descrição      :  
    719          *   Parametros     :
    720          *   Retorno        :  
    721          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    722          signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
    723          {
   \                     xQueueIsQueueEmptyFromISR:
   \   00000000   0x0001             MOVS     R1,R0
    724          signed portBASE_TYPE xReturn;
    725          
    726          	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
   \   00000002   0x6B8A             LDR      R2,[R1, #+56]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??xQueueIsQueueEmptyFromISR_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE000             B.N      ??xQueueIsQueueEmptyFromISR_1
   \                     ??xQueueIsQueueEmptyFromISR_0:
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??xQueueIsQueueEmptyFromISR_1:
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
    727          
    728          	return xReturn;
   \   00000010   0x4770             BX       LR               ;; return
    729          }
    730          /********************************************************************************
    731          *   Descrição      :  
    732          *   Parametros     :
    733          *   Retorno        :  
    734          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    735          static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
    736          {
   \                     prvIsQueueFull:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    737          signed portBASE_TYPE xReturn;
    738          
    739          	taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
    740          		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
   \   00000008   0x6BA0             LDR      R0,[R4, #+56]
   \   0000000A   0x6BE1             LDR      R1,[R4, #+60]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD101             BNE.N    ??prvIsQueueFull_0
   \   00000010   0x2501             MOVS     R5,#+1
   \   00000012   0xE000             B.N      ??prvIsQueueFull_1
   \                     ??prvIsQueueFull_0:
   \   00000014   0x2500             MOVS     R5,#+0
   \                     ??prvIsQueueFull_1:
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
    741          	taskEXIT_CRITICAL();
   \   00000018   0x.... 0x....      BL       vPortExitCritical
    742          
    743          	return xReturn;
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    744          }
    745          /********************************************************************************
    746          *   Descrição      :  
    747          *   Parametros     :
    748          *   Retorno        :  
    749          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    750          signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
    751          {
   \                     xQueueIsQueueFullFromISR:
   \   00000000   0x0001             MOVS     R1,R0
    752          signed portBASE_TYPE xReturn;
    753          
    754          	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
   \   00000002   0x6B8A             LDR      R2,[R1, #+56]
   \   00000004   0x6BCB             LDR      R3,[R1, #+60]
   \   00000006   0x429A             CMP      R2,R3
   \   00000008   0xD101             BNE.N    ??xQueueIsQueueFullFromISR_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??xQueueIsQueueFullFromISR_1
   \                     ??xQueueIsQueueFullFromISR_0:
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??xQueueIsQueueFullFromISR_1:
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
    755          
    756          	return xReturn;
   \   00000012   0x4770             BX       LR               ;; return
    757          }
    758          /********************************************************************************
    759          *   Descrição      :  
    760          *   Parametros     :
    761          *   Retorno        :  
    762          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    763          void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
    764          {
    765          unsigned portBASE_TYPE ux;
    766          
    767              for( ux = 0; ux < configQUEUE_REGISTRY_SIZE; ux++ )
   \                     vQueueAddToRegistry:
   \   00000000   0x2300             MOVS     R3,#+0
   \   00000002   0x001A             MOVS     R2,R3
   \                     ??vQueueAddToRegistry_0:
   \   00000004   0x2A0A             CMP      R2,#+10
   \   00000006   0xD20E             BCS.N    ??vQueueAddToRegistry_1
    768              {
    769          	if( xQueueRegistry[ ux ].pcQueueName == NULL )
   \   00000008   0x....             LDR.N    R3,??DataTable1
   \   0000000A   0xF853 0x3032      LDR      R3,[R3, R2, LSL #+3]
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD107             BNE.N    ??vQueueAddToRegistry_2
    770          	{
    771          	    xQueueRegistry[ ux ].pcQueueName = pcQueueName;
   \   00000012   0x....             LDR.N    R3,??DataTable1
   \   00000014   0xF843 0x1032      STR      R1,[R3, R2, LSL #+3]
    772          	    xQueueRegistry[ ux ].xHandle = xQueue;
   \   00000018   0x....             LDR.N    R3,??DataTable1
   \   0000001A   0xEB13 0x03C2      ADDS     R3,R3,R2, LSL #+3
   \   0000001E   0x6058             STR      R0,[R3, #+4]
    773          	    break;
   \   00000020   0xE001             B.N      ??vQueueAddToRegistry_1
    774          	}
    775              }
   \                     ??vQueueAddToRegistry_2:
   \   00000022   0x1C52             ADDS     R2,R2,#+1
   \   00000024   0xE7EE             B.N      ??vQueueAddToRegistry_0
    776          }
   \                     ??vQueueAddToRegistry_1:
   \   00000026   0x4770             BX       LR               ;; return
    777          /********************************************************************************
    778          *   Descrição      :  
    779          *   Parametros     :
    780          *   Retorno        :  
    781          ********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    782          static void vQueueUnregisterQueue( xQueueHandle xQueue )
    783          {
    784              unsigned portBASE_TYPE ux;
    785          
    786          	
    787              for( ux = 0; ux < configQUEUE_REGISTRY_SIZE; ux++ )
   \                     vQueueUnregisterQueue:
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x0011             MOVS     R1,R2
   \                     ??vQueueUnregisterQueue_0:
   \   00000004   0x290A             CMP      R1,#+10
   \   00000006   0xD20C             BCS.N    ??vQueueUnregisterQueue_1
    788              {
    789          	if( xQueueRegistry[ ux ].xHandle == xQueue )
   \   00000008   0x....             LDR.N    R2,??DataTable1
   \   0000000A   0xEB12 0x02C1      ADDS     R2,R2,R1, LSL #+3
   \   0000000E   0x6852             LDR      R2,[R2, #+4]
   \   00000010   0x4282             CMP      R2,R0
   \   00000012   0xD104             BNE.N    ??vQueueUnregisterQueue_2
    790          	{
    791          	    xQueueRegistry[ ux ].pcQueueName = NULL;
   \   00000014   0x....             LDR.N    R2,??DataTable1
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0xF842 0x3031      STR      R3,[R2, R1, LSL #+3]
    792          	    break;
   \   0000001C   0xE001             B.N      ??vQueueUnregisterQueue_1
    793          	}
    794              }
   \                     ??vQueueUnregisterQueue_2:
   \   0000001E   0x1C49             ADDS     R1,R1,#+1
   \   00000020   0xE7F0             B.N      ??vQueueUnregisterQueue_0
    795          
    796          }
   \                     ??vQueueUnregisterQueue_1:
   \   00000022   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     xQueueRegistry
    797          /********************************************************************************
    798          *   Fim do arquivo
    799          ********************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   memcpy
        16   -> __aeabi_memcpy
      16   prvCopyDataFromQueue
        16   -> memcpy
      16   prvCopyDataToQueue
        16   -> memcpy
        16   -> vTaskPriorityDisinherit
      16   prvIsQueueEmpty
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
      16   prvIsQueueFull
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       8   prvUnlockQueue
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
         8   -> vTaskMissedYield
         8   -> xTaskRemoveFromEventList
      16   uxQueueMessagesWaiting
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       0   uxQueueMessagesWaitingFromISR
       0   vQueueAddToRegistry
       8   vQueueDelete
         8   -> vPortFree
         8   -> vQueueUnregisterQueue
       0   vQueueUnregisterQueue
      24   xQueueCreate
        24   -> pvPortMalloc
        24   -> vListInitialise
        24   -> vPortFree
       8   xQueueCreateMutex
         8   -> pvPortMalloc
         8   -> vListInitialise
         8   -> xQueueGenericSend
      40   xQueueGenericReceive
        40   -> prvCopyDataFromQueue
        40   -> prvIsQueueEmpty
        40   -> prvUnlockQueue
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
        40   -> vPortYieldFromISR
        40   -> vTaskPlaceOnEventList
        40   -> vTaskPriorityInherit
        40   -> vTaskSetTimeOutState
        40   -> vTaskSuspendAll
        40   -> xTaskCheckForTimeOut
        40   -> xTaskGetCurrentTaskHandle
        40   -> xTaskRemoveFromEventList
        40   -> xTaskResumeAll
      32   xQueueGenericSend
        32   -> prvCopyDataToQueue
        32   -> prvIsQueueFull
        32   -> prvUnlockQueue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vPortYieldFromISR
        32   -> vTaskPlaceOnEventList
        32   -> vTaskSetTimeOutState
        32   -> vTaskSuspendAll
        32   -> xTaskCheckForTimeOut
        32   -> xTaskRemoveFromEventList
        32   -> xTaskResumeAll
      32   xQueueGenericSendFromISR
        32   -> prvCopyDataToQueue
        32   -> vPortClearInterruptMask
        32   -> vPortSetInterruptMask
        32   -> xTaskRemoveFromEventList
      16   xQueueGiveMutexRecursive
        16   -> xQueueGenericSend
        16   -> xTaskGetCurrentTaskHandle
       0   xQueueIsQueueEmptyFromISR
       0   xQueueIsQueueFullFromISR
      24   xQueueReceiveFromISR
        24   -> prvCopyDataFromQueue
        24   -> vPortClearInterruptMask
        24   -> vPortSetInterruptMask
        24   -> xTaskRemoveFromEventList
      24   xQueueTakeMutexRecursive
        24   -> xQueueGenericReceive
        24   -> xTaskGetCurrentTaskHandle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
      22  memcpy
      44  prvCopyDataFromQueue
     114  prvCopyDataToQueue
      30  prvIsQueueEmpty
      32  prvIsQueueFull
     106  prvUnlockQueue
      20  uxQueueMessagesWaiting
       8  uxQueueMessagesWaitingFromISR
      40  vQueueAddToRegistry
      24  vQueueDelete
      36  vQueueUnregisterQueue
     116  xQueueCreate
      86  xQueueCreateMutex
     288  xQueueGenericReceive
     210  xQueueGenericSend
      96  xQueueGenericSendFromISR
      52  xQueueGiveMutexRecursive
      18  xQueueIsQueueEmptyFromISR
      20  xQueueIsQueueFullFromISR
      96  xQueueReceiveFromISR
      80  xQueueRegistry
      56  xQueueTakeMutexRecursive

 
    80 bytes in section .bss
 1 518 bytes in section .text
 
 1 496 bytes of CODE memory (+ 22 bytes shared)
    80 bytes of DATA memory

Errors: none
Warnings: none
