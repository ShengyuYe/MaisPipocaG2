###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      10/Jul/2017  15:28:15 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Drivers\Protocolo\Protocolo.c             #
#    Command line =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Drivers\Protocolo\Protocolo.c -lC         #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\ -lA                           #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\ -o                            #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\Obj\ --no_cse --no_unroll           #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -Ol                                               #
#    List file    =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\Protocolo.lst                  #
#    Object file  =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\Obj\Protocolo.o                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPipocaG2\SOFTWARE\Drivers\Protocolo\Protocolo.c
      1          /*__________________________________________________________________________________
      2          |	Quark Tecnologia Eletrônica Embarcada
      3          |       
      4          |       Itapema - SC
      5          |       www.quarktee.com.br
      6          | __________________________________________________________________________________
      7          |
      8          |       This source code was developed by Quark  and cannot be copied, in part 
      9          |       or in whole, or used, except when legally licensed by Quark 
     10          |       or its distributors.
     11          |
     12          |       Este código é propriedade da Quark  e não pode ser copiado, em parte 
     13          |       ou em todo, ou utilizado, exceto quando for legalmente licenciado pela 
     14          |       Quark  ou por um de seus distribuidores.
     15          | __________________________________________________________________________________
     16          |
     17          |       Arquivo            :  Protocolo.c
     18          | 
     19          |       Autor              :  Marcos Aquino
     20          |       Data criação       :  21/02/2014
     21          |
     22          |       Revisões           :  1.0.0.0
     23          |
     24          |
     25          | __________________________________________________________________________________
     26          */
     27          
     28          /***********************************************************************************
     29          *       Includes
     30          ***********************************************************************************/
     31          #include <nxp\iolpc1768.h>

   \                                 In section .noinit, at 0xe000e280
   \   __absolute union <unnamed> volatile _A_CLRPEND0
   \                     _A_CLRPEND0:
   \   00000000                      DS8 4

   \                                 In section .noinit, at 0x4009c000
   \   __absolute unsigned char volatile U3RBRTHR
   \                     U3RBRTHR:
   \   00000000                      DS8 1

   \                                 In section .noinit, at 0x4009c008
   \   __absolute union <unnamed> volatile _A_U3FCR
   \                     _A_U3FCR:
   \   00000000                      DS8 4

   \                                 In section .noinit, at 0x4009c014
   \   __absolute union <unnamed> const volatile _A_U3LSR
   \                     _A_U3LSR:
   \   00000000                      DS8 1
     32          #include <stdio.h>
     33          #include <stdlib.h>
     34          #include <string.h>
     35          #include "protocolo.h"
     36          #include "..\..\includes.h"
     37          
     38          /***********************************************************************************
     39          *       Definições locais
     40          ***********************************************************************************/
     41          #define TAM_BUF_TX                              1024
     42          #define TAM_BUF_RX                              128
     43          
     44          #define STX                                     0x02
     45          #define ETX                                     0x03
     46          #define DLE                                     0x10
     47          
     48          /***********************************************************************************
     49          *       Variaveis locais
     50          ***********************************************************************************/

   \                                 In section .bss, align 4
     51          unsigned char PROTOCOLO_bufferTx[TAM_BUF_TX];
   \                     PROTOCOLO_bufferTx:
   \   00000000                      DS8 1024

   \                                 In section .bss, align 4
     52          unsigned char PROTOCOLO_bufferRx[TAM_BUF_RX];
   \                     PROTOCOLO_bufferRx:
   \   00000000                      DS8 128

   \                                 In section .bss, align 4
     53          unsigned char PROTOCOLO_bufferTmp[TAM_BUF_TX];
   \                     PROTOCOLO_bufferTmp:
   \   00000000                      DS8 1024

   \                                 In section .bss, align 1
     54          unsigned char PROTOCOLO_bytesRecebidos;
   \                     PROTOCOLO_bytesRecebidos:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     55          unsigned char PROTOCOLO_bytesParaEnviar;
   \                     PROTOCOLO_bytesParaEnviar:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     56          unsigned char PROTOCOLO_bytesEnviados;
   \                     PROTOCOLO_bytesEnviados:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     57          unsigned char PROTOCOLO_novoPacote=0;
   \                     PROTOCOLO_novoPacote:
   \   00000000                      DS8 1
     58          
     59          
     60          /***********************************************************************************
     61          *       Funções locais
     62          ***********************************************************************************/
     63          void PROTOCOLO_enviaPacote(unsigned char *pData,unsigned short int tamanho);
     64          unsigned char PROTOCOLO_checksum(unsigned char*pData,unsigned short int tamanho);
     65          void PROTOCOLO_get_device(void);
     66          
     67          /***********************************************************************************
     68          *       Implementação das funções
     69          ***********************************************************************************/
     70          
     71          /***********************************************************************************
     72          *       Descrição       :       Inicialização da biblioteca
     73          *       Parametros      :       nenhum
     74          *       Retorno         :       nenhum
     75          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     76          void PROTOCOLO_ini(void){
   \                     PROTOCOLO_ini:
   \   00000000   0xB580             PUSH     {R7,LR}
     77            
     78            UART_init(3,119200,NULL,NULL,NULL);    
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable6  ;; 0x1d1a0
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0x.... 0x....      BL       UART_init
     79          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
     80          /***********************************************************************************
     81          *       Descrição       :       Função para tratamento da interrupção
     82          *                               da uart3
     83          *       Parametros      :       nenhum
     84          *       Retorno         :       nenhum
     85          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     86          void PROTOCOLO_intVect(void){  
     87            static unsigned char ultimoRecebido=0;
     88            unsigned char dummy;
     89            
     90            switch(U3IIR_bit.IID){
   \                     PROTOCOLO_intVect:
   \   00000000   0x....             LDR.N    R0,??DataTable6_1  ;; 0x4009c008
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0840             LSRS     R0,R0,#+1
   \   00000006   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD008             BEQ.N    ??PROTOCOLO_intVect_0
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD01B             BEQ.N    ??PROTOCOLO_intVect_1
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xF000 0x8083      BEQ.W    ??PROTOCOLO_intVect_2
   \   00000018   0x2806             CMP      R0,#+6
   \   0000001A   0xF000 0x8086      BEQ.W    ??PROTOCOLO_intVect_3
   \   0000001E   0xE084             B.N      ??PROTOCOLO_intVect_4
     91              case THRE:
     92                         if(PROTOCOLO_bytesParaEnviar){
   \                     ??PROTOCOLO_intVect_0:
   \   00000020   0x....             LDR.N    R0,??DataTable6_2
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD00F             BEQ.N    ??PROTOCOLO_intVect_5
     93                           U3THR = PROTOCOLO_bufferTx[PROTOCOLO_bytesEnviados++];
   \   00000028   0x....             LDR.N    R0,??DataTable6_3
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x....             LDR.N    R1,??DataTable6_4
   \   0000002E   0x5C40             LDRB     R0,[R0, R1]
   \   00000030   0x....             LDR.N    R1,??DataTable6_5  ;; 0x4009c000
   \   00000032   0x7008             STRB     R0,[R1, #+0]
   \   00000034   0x....             LDR.N    R0,??DataTable6_3
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0x....             LDR.N    R1,??DataTable6_3
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
     94                           PROTOCOLO_bytesParaEnviar--;
   \   0000003E   0x....             LDR.N    R0,??DataTable6_2
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   \   00000044   0x....             LDR.N    R1,??DataTable6_2
   \   00000046   0x7008             STRB     R0,[R1, #+0]
     95                         }
     96                         break; 
   \                     ??PROTOCOLO_intVect_5:
   \   00000048   0xE06F             B.N      ??PROTOCOLO_intVect_4
     97              case RDA : dummy = U3RBR;
   \                     ??PROTOCOLO_intVect_1:
   \   0000004A   0x....             LDR.N    R0,??DataTable6_5  ;; 0x4009c000
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
     98                         switch(dummy){
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x0001             MOVS     R1,R0
   \   00000052   0x2902             CMP      R1,#+2
   \   00000054   0xD004             BEQ.N    ??PROTOCOLO_intVect_6
   \   00000056   0x2903             CMP      R1,#+3
   \   00000058   0xD01E             BEQ.N    ??PROTOCOLO_intVect_7
   \   0000005A   0x2910             CMP      R1,#+16
   \   0000005C   0xD038             BEQ.N    ??PROTOCOLO_intVect_8
   \   0000005E   0xE050             B.N      ??PROTOCOLO_intVect_9
     99                           case STX: // Quando receber [DLE]+[STX] - marca inicio de novo pacote
    100                                     if(ultimoRecebido == DLE){
   \                     ??PROTOCOLO_intVect_6:
   \   00000060   0x....             LDR.N    R1,??DataTable6_6
   \   00000062   0x7809             LDRB     R1,[R1, #+0]
   \   00000064   0x2910             CMP      R1,#+16
   \   00000066   0xD106             BNE.N    ??PROTOCOLO_intVect_10
    101                                       PROTOCOLO_bytesRecebidos = 0;
   \   00000068   0x....             LDR.N    R0,??DataTable6_7
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x7001             STRB     R1,[R0, #+0]
    102                                       ultimoRecebido = 255;
   \   0000006E   0x....             LDR.N    R0,??DataTable6_6
   \   00000070   0x21FF             MOVS     R1,#+255
   \   00000072   0x7001             STRB     R1,[R0, #+0]
   \   00000074   0xE00F             B.N      ??PROTOCOLO_intVect_11
    103                                     }
    104                                     else{
    105                                       if(PROTOCOLO_bytesRecebidos<(TAM_BUF_RX-1)) 
   \                     ??PROTOCOLO_intVect_10:
   \   00000076   0x....             LDR.N    R1,??DataTable6_7
   \   00000078   0x7809             LDRB     R1,[R1, #+0]
   \   0000007A   0x297F             CMP      R1,#+127
   \   0000007C   0xDA08             BGE.N    ??PROTOCOLO_intVect_12
    106                                         PROTOCOLO_bufferRx[PROTOCOLO_bytesRecebidos++] = dummy;                                                         
   \   0000007E   0x....             LDR.N    R1,??DataTable6_7
   \   00000080   0x7809             LDRB     R1,[R1, #+0]
   \   00000082   0x....             LDR.N    R2,??DataTable6_8
   \   00000084   0x5488             STRB     R0,[R1, R2]
   \   00000086   0x....             LDR.N    R0,??DataTable6_7
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
   \   0000008C   0x....             LDR.N    R1,??DataTable6_7
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
    107                                       
    108                                       ultimoRecebido = STX;
   \                     ??PROTOCOLO_intVect_12:
   \   00000090   0x....             LDR.N    R0,??DataTable6_6
   \   00000092   0x2102             MOVS     R1,#+2
   \   00000094   0x7001             STRB     R1,[R0, #+0]
    109                                     }
    110                                     
    111                                     break;
   \                     ??PROTOCOLO_intVect_11:
   \   00000096   0xE041             B.N      ??PROTOCOLO_intVect_13
    112                           case ETX: // Quando receber [DLE]+[ETX] - marca fim do novo pacote
    113                                     if(ultimoRecebido == DLE){
   \                     ??PROTOCOLO_intVect_7:
   \   00000098   0x....             LDR.N    R1,??DataTable6_6
   \   0000009A   0x7809             LDRB     R1,[R1, #+0]
   \   0000009C   0x2910             CMP      R1,#+16
   \   0000009E   0xD106             BNE.N    ??PROTOCOLO_intVect_14
    114                                       PROTOCOLO_novoPacote = 255;
   \   000000A0   0x....             LDR.N    R0,??DataTable6_9
   \   000000A2   0x21FF             MOVS     R1,#+255
   \   000000A4   0x7001             STRB     R1,[R0, #+0]
    115                                       ultimoRecebido = 255;
   \   000000A6   0x....             LDR.N    R0,??DataTable6_6
   \   000000A8   0x21FF             MOVS     R1,#+255
   \   000000AA   0x7001             STRB     R1,[R0, #+0]
   \   000000AC   0xE00F             B.N      ??PROTOCOLO_intVect_15
    116                                     }
    117                                     else{
    118                                       if(PROTOCOLO_bytesRecebidos<(TAM_BUF_RX-1)) 
   \                     ??PROTOCOLO_intVect_14:
   \   000000AE   0x....             LDR.N    R1,??DataTable6_7
   \   000000B0   0x7809             LDRB     R1,[R1, #+0]
   \   000000B2   0x297F             CMP      R1,#+127
   \   000000B4   0xDA08             BGE.N    ??PROTOCOLO_intVect_16
    119                                         PROTOCOLO_bufferRx[PROTOCOLO_bytesRecebidos++] = dummy;                                                         
   \   000000B6   0x....             LDR.N    R1,??DataTable6_7
   \   000000B8   0x7809             LDRB     R1,[R1, #+0]
   \   000000BA   0x....             LDR.N    R2,??DataTable6_8
   \   000000BC   0x5488             STRB     R0,[R1, R2]
   \   000000BE   0x....             LDR.N    R0,??DataTable6_7
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0x1C40             ADDS     R0,R0,#+1
   \   000000C4   0x....             LDR.N    R1,??DataTable6_7
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
    120                                       
    121                                       ultimoRecebido = ETX;
   \                     ??PROTOCOLO_intVect_16:
   \   000000C8   0x....             LDR.N    R0,??DataTable6_6
   \   000000CA   0x2103             MOVS     R1,#+3
   \   000000CC   0x7001             STRB     R1,[R0, #+0]
    122                                     }                   
    123                                     break;
   \                     ??PROTOCOLO_intVect_15:
   \   000000CE   0xE025             B.N      ??PROTOCOLO_intVect_13
    124                           case DLE: // Quando receber [DLE]+[DLE] recebe 0x10 dentro do buffer
    125                                     if(ultimoRecebido == DLE){
   \                     ??PROTOCOLO_intVect_8:
   \   000000D0   0x....             LDR.N    R1,??DataTable6_6
   \   000000D2   0x7809             LDRB     R1,[R1, #+0]
   \   000000D4   0x2910             CMP      R1,#+16
   \   000000D6   0xD110             BNE.N    ??PROTOCOLO_intVect_17
    126                                       if(PROTOCOLO_bytesRecebidos<(TAM_BUF_RX-1))
   \   000000D8   0x....             LDR.N    R1,??DataTable6_7
   \   000000DA   0x7809             LDRB     R1,[R1, #+0]
   \   000000DC   0x297F             CMP      R1,#+127
   \   000000DE   0xDA08             BGE.N    ??PROTOCOLO_intVect_18
    127                                         PROTOCOLO_bufferRx[PROTOCOLO_bytesRecebidos++] = dummy;
   \   000000E0   0x....             LDR.N    R1,??DataTable6_7
   \   000000E2   0x7809             LDRB     R1,[R1, #+0]
   \   000000E4   0x....             LDR.N    R2,??DataTable6_8
   \   000000E6   0x5488             STRB     R0,[R1, R2]
   \   000000E8   0x....             LDR.N    R0,??DataTable6_7
   \   000000EA   0x7800             LDRB     R0,[R0, #+0]
   \   000000EC   0x1C40             ADDS     R0,R0,#+1
   \   000000EE   0x....             LDR.N    R1,??DataTable6_7
   \   000000F0   0x7008             STRB     R0,[R1, #+0]
    128                                       ultimoRecebido = 255;
   \                     ??PROTOCOLO_intVect_18:
   \   000000F2   0x....             LDR.N    R0,??DataTable6_6
   \   000000F4   0x21FF             MOVS     R1,#+255
   \   000000F6   0x7001             STRB     R1,[R0, #+0]
   \   000000F8   0xE002             B.N      ??PROTOCOLO_intVect_19
    129                                     }                      
    130                                     else
    131                                       ultimoRecebido = DLE;
   \                     ??PROTOCOLO_intVect_17:
   \   000000FA   0x....             LDR.N    R0,??DataTable6_6
   \   000000FC   0x2110             MOVS     R1,#+16
   \   000000FE   0x7001             STRB     R1,[R0, #+0]
    132                                     break;
   \                     ??PROTOCOLO_intVect_19:
   \   00000100   0xE00C             B.N      ??PROTOCOLO_intVect_13
    133                           default :
    134                                     if(PROTOCOLO_bytesRecebidos<(TAM_BUF_RX-1)) 
   \                     ??PROTOCOLO_intVect_9:
   \   00000102   0x....             LDR.N    R1,??DataTable6_7
   \   00000104   0x7809             LDRB     R1,[R1, #+0]
   \   00000106   0x297F             CMP      R1,#+127
   \   00000108   0xDA08             BGE.N    ??PROTOCOLO_intVect_20
    135                                       PROTOCOLO_bufferRx[PROTOCOLO_bytesRecebidos++] = dummy;                                                                            
   \   0000010A   0x....             LDR.N    R1,??DataTable6_7
   \   0000010C   0x7809             LDRB     R1,[R1, #+0]
   \   0000010E   0x....             LDR.N    R2,??DataTable6_8
   \   00000110   0x5488             STRB     R0,[R1, R2]
   \   00000112   0x....             LDR.N    R0,??DataTable6_7
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0x1C40             ADDS     R0,R0,#+1
   \   00000118   0x....             LDR.N    R1,??DataTable6_7
   \   0000011A   0x7008             STRB     R0,[R1, #+0]
    136                                     break;
    137                         }
    138                         
    139                         //ultimoRecebido = dummy;
    140                         break;      
   \                     ??PROTOCOLO_intVect_20:
   \                     ??PROTOCOLO_intVect_13:
   \   0000011C   0xE005             B.N      ??PROTOCOLO_intVect_4
    141              case RLS : 
    142                         dummy = U3LSR;
   \                     ??PROTOCOLO_intVect_2:
   \   0000011E   0x....             LDR.N    R0,??DataTable6_10  ;; 0x4009c014
   \   00000120   0x7800             LDRB     R0,[R0, #+0]
    143                         dummy = U3RBR;               
   \   00000122   0x....             LDR.N    R1,??DataTable6_5  ;; 0x4009c000
   \   00000124   0x7809             LDRB     R1,[R1, #+0]
   \   00000126   0x0008             MOVS     R0,R1
    144                         break;      
   \   00000128   0xE7FF             B.N      ??PROTOCOLO_intVect_4
    145              case CTI :
    146                         break;      
    147            }  
    148            
    149            //Apaga o flag de interrupção pendente
    150            CLRPEND0 |= (0x01)<<5;       
   \                     ??PROTOCOLO_intVect_3:
   \                     ??PROTOCOLO_intVect_4:
   \   0000012A   0x....             LDR.N    R0,??DataTable6_11  ;; 0xe000e280
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000132   0x....             LDR.N    R1,??DataTable6_11  ;; 0xe000e280
   \   00000134   0x6008             STR      R0,[R1, #+0]
    151          }
   \   00000136   0x4770             BX       LR               ;; return
   \   00000138                      REQUIRE U3RBRTHR
   \   00000138                      REQUIRE _A_U3LSR
   \   00000138                      REQUIRE _A_U3FCR
   \   00000138                      REQUIRE _A_CLRPEND0

   \                                 In section .bss, align 1
   \                     ??ultimoRecebido:
   \   00000000                      DS8 1
    152          /***********************************************************************************
    153          *       Descrição       :       Tick de timer para a biblioteca do protocolo
    154          *       Parametros      :       nenhum
    155          *       Retorno         :       nenhum
    156          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    157          void PROTOCOLO_timerTick(void){
    158            
    159            
    160            
    161          }
   \                     PROTOCOLO_timerTick:
   \   00000000   0x4770             BX       LR               ;; return
    162          /***********************************************************************************
    163          *       Descrição       :       Calcula o checksum de um pacote de dados
    164          *       Parametros      :       (unsigned char*) ponteiro para o início do pacote
    165          *                               (unsigned short int) tamanho do pacote
    166          *       Retorno         :       (unsigned char) checksum do pacote
    167          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    168          unsigned char PROTOCOLO_checksum(unsigned char*pData,unsigned short int tamanho){
   \                     PROTOCOLO_checksum:
   \   00000000   0xB410             PUSH     {R4}
    169            unsigned short int soma=0;
   \   00000002   0x2200             MOVS     R2,#+0
    170          
    171            for(unsigned short int i=0;i<tamanho;i++)
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0xE003             B.N      ??PROTOCOLO_checksum_0
    172              soma+= pData[i];
   \                     ??PROTOCOLO_checksum_1:
   \   00000008   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000000A   0x5C1C             LDRB     R4,[R3, R0]
   \   0000000C   0x18A2             ADDS     R2,R4,R2
   \   0000000E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??PROTOCOLO_checksum_0:
   \   00000010   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000012   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000014   0x428B             CMP      R3,R1
   \   00000016   0xD3F7             BCC.N    ??PROTOCOLO_checksum_1
    173            
    174            return (unsigned char)(256-soma);    
   \   00000018   0x4250             RSBS     R0,R2,#+0
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
    175          }
    176          /***********************************************************************************
    177          *       Descrição       :       Thread do protocolo
    178          *       Protocolo       :       (void*) pPar
    179          *       Retorno         :       nenhum
    180          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    181          void PROTOCOLO_main(void*pPar){
   \                     PROTOCOLO_main:
   \   00000000   0xB580             PUSH     {R7,LR}
    182            
    183            PROTOCOLO_ini();
   \   00000002   0x.... 0x....      BL       PROTOCOLO_ini
   \   00000006   0xE002             B.N      ??PROTOCOLO_main_0
    184            
    185            for(;;){        
    186              
    187              if(PROTOCOLO_novoPacote){
    188                
    189                PROTOCOLO_novoPacote = 0;
    190                if(PROTOCOLO_checksum(PROTOCOLO_bufferRx,PROTOCOLO_bufferRx[1]-1)==PROTOCOLO_bufferRx[PROTOCOLO_bytesRecebidos-1]){      
    191                  switch(PROTOCOLO_bufferRx[0]){      
    192                    case DXTNET_GET_DEVICE:
    193                         PROTOCOLO_get_device();
    194                         break;
    195                    case DXTNET_READ_PARAMETERS:
    196                         break;
    197                    case DXTNET_WRITE_PARAMETERS:
    198                         break;
    199                    case DXTNET_READ_FILE_TABLE:
    200                         break;
    201                    case DXTNET_WRITE_FILE_TABLE:
    202                         break;
    203                    case DXTNET_DELETE_FILE_TABLE:
    204                         break;
    205                    case DXTNET_READ_FILE:
    206                         break;
    207                    case DXTNET_WRITE_FILE:
    208                         break;
    209                  }    
    210                }
    211              }
    212              vTaskDelay(1);
   \                     ??PROTOCOLO_main_1:
   \                     ??PROTOCOLO_main_2:
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       vTaskDelay
   \                     ??PROTOCOLO_main_0:
   \   0000000E   0x....             LDR.N    R0,??DataTable6_9
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD0F8             BEQ.N    ??PROTOCOLO_main_2
   \   00000016   0x....             LDR.N    R0,??DataTable6_9
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
   \   0000001C   0x....             LDR.N    R0,??DataTable6_8
   \   0000001E   0x7840             LDRB     R0,[R0, #+1]
   \   00000020   0x1E41             SUBS     R1,R0,#+1
   \   00000022   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000024   0x....             LDR.N    R0,??DataTable6_8
   \   00000026   0x.... 0x....      BL       PROTOCOLO_checksum
   \   0000002A   0x....             LDR.N    R1,??DataTable6_7
   \   0000002C   0x7809             LDRB     R1,[R1, #+0]
   \   0000002E   0x....             LDR.N    R2,??DataTable6_8
   \   00000030   0x1889             ADDS     R1,R1,R2
   \   00000032   0xF811 0x1C01      LDRB     R1,[R1, #-1]
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD1E5             BNE.N    ??PROTOCOLO_main_2
   \   0000003C   0x....             LDR.N    R0,??DataTable6_8
   \   0000003E   0x7800             LDRB     R0,[R0, #+0]
   \   00000040   0x2810             CMP      R0,#+16
   \   00000042   0xD00C             BEQ.N    ??PROTOCOLO_main_3
   \   00000044   0xD3E0             BCC.N    ??PROTOCOLO_main_2
   \   00000046   0x2812             CMP      R0,#+18
   \   00000048   0xD00D             BEQ.N    ??PROTOCOLO_main_4
   \   0000004A   0xD30B             BCC.N    ??PROTOCOLO_main_5
   \   0000004C   0x2814             CMP      R0,#+20
   \   0000004E   0xD00C             BEQ.N    ??PROTOCOLO_main_6
   \   00000050   0xD30A             BCC.N    ??PROTOCOLO_main_7
   \   00000052   0x2816             CMP      R0,#+22
   \   00000054   0xD00B             BEQ.N    ??PROTOCOLO_main_8
   \   00000056   0xD309             BCC.N    ??PROTOCOLO_main_9
   \   00000058   0x2817             CMP      R0,#+23
   \   0000005A   0xD0D5             BEQ.N    ??PROTOCOLO_main_1
   \   0000005C   0xE7D4             B.N      ??PROTOCOLO_main_2
   \                     ??PROTOCOLO_main_3:
   \   0000005E   0x.... 0x....      BL       PROTOCOLO_get_device
   \   00000062   0xE7D1             B.N      ??PROTOCOLO_main_2
   \                     ??PROTOCOLO_main_5:
   \   00000064   0xE7D0             B.N      ??PROTOCOLO_main_2
   \                     ??PROTOCOLO_main_4:
   \   00000066   0xE7CF             B.N      ??PROTOCOLO_main_2
   \                     ??PROTOCOLO_main_7:
   \   00000068   0xE7CE             B.N      ??PROTOCOLO_main_2
   \                     ??PROTOCOLO_main_6:
   \   0000006A   0xE7CD             B.N      ??PROTOCOLO_main_2
   \                     ??PROTOCOLO_main_9:
   \   0000006C   0xE7CC             B.N      ??PROTOCOLO_main_2
   \                     ??PROTOCOLO_main_8:
   \   0000006E   0xE7CB             B.N      ??PROTOCOLO_main_2
    213            }    
    214          }
    215          /***********************************************************************************
    216          *       Descrição       :       Faz a decodificação do comando getdevice
    217          *       Parametros      :       nenhum
    218          *       Retorno         :       nenhum
    219          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    220          void PROTOCOLO_get_device(void){
   \                     PROTOCOLO_get_device:
   \   00000000   0xB580             PUSH     {R7,LR}
    221            
    222            PROTOCOLO_bufferTmp[0]  = DXTNET_GET_DEVICE;
   \   00000002   0x....             LDR.N    R0,??DataTable6_12
   \   00000004   0x2110             MOVS     R1,#+16
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    223            PROTOCOLO_bufferTmp[2]  = DXTNET_MAIS_PIPOCA_G2;
   \   00000008   0x....             LDR.N    R0,??DataTable6_12
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x7081             STRB     R1,[R0, #+2]
    224            
    225            sprintf((char*)&PROTOCOLO_bufferTmp[3],STRING_VERSAO_PROTOCOLO);
   \   0000000E   0x....             LDR.N    R1,??DataTable6_13
   \   00000010   0x....             LDR.N    R0,??DataTable6_14
   \   00000012   0x.... 0x....      BL       sprintf
    226            PROTOCOLO_enviaPacote(PROTOCOLO_bufferTmp,21);  
   \   00000016   0x2115             MOVS     R1,#+21
   \   00000018   0x....             LDR.N    R0,??DataTable6_12
   \   0000001A   0x.... 0x....      BL       PROTOCOLO_enviaPacote
    227          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    228          /***********************************************************************************
    229          *       Descrição       :       Encapsula os dados que serão enviados
    230          *                               pela rede
    231          *       Parametros      :       (unsigned char*) ponteiro para os dados que serão
    232          *                                               enviados
    233          *       Retorno         :       nenhum
    234          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    235          void PROTOCOLO_enviaPacote(unsigned char *pData,unsigned short int tamanho){
   \                     PROTOCOLO_enviaPacote:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    236            unsigned char indice=0;
   \   00000006   0x2600             MOVS     R6,#+0
    237            
    238            pData[1] = tamanho;
   \   00000008   0x7065             STRB     R5,[R4, #+1]
    239            pData[tamanho-1] = PROTOCOLO_checksum(pData,tamanho-1);
   \   0000000A   0x1E69             SUBS     R1,R5,#+1
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       PROTOCOLO_checksum
   \   00000014   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000016   0x1929             ADDS     R1,R5,R4
   \   00000018   0xF801 0x0C01      STRB     R0,[R1, #-1]
    240            
    241            PROTOCOLO_bufferTx[indice++] = DLE;
   \   0000001C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001E   0x....             LDR.N    R0,??DataTable6_4
   \   00000020   0x2110             MOVS     R1,#+16
   \   00000022   0x5431             STRB     R1,[R6, R0]
   \   00000024   0x1C76             ADDS     R6,R6,#+1
    242            PROTOCOLO_bufferTx[indice++] = STX;
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0x....             LDR.N    R0,??DataTable6_4
   \   0000002A   0x2102             MOVS     R1,#+2
   \   0000002C   0x5431             STRB     R1,[R6, R0]
   \   0000002E   0x1C76             ADDS     R6,R6,#+1
    243            for(unsigned char i=0;i<tamanho;i++)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE006             B.N      ??PROTOCOLO_enviaPacote_0
    244              if(pData[i]==DLE){
    245                PROTOCOLO_bufferTx[indice++] = DLE;
    246                PROTOCOLO_bufferTx[indice++] = DLE;
    247              }
    248              else
    249                PROTOCOLO_bufferTx[indice++] = pData[i];
   \                     ??PROTOCOLO_enviaPacote_1:
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x5D01             LDRB     R1,[R0, R4]
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x....             LDR.N    R2,??DataTable6_4
   \   0000003C   0x54B1             STRB     R1,[R6, R2]
   \   0000003E   0x1C76             ADDS     R6,R6,#+1
   \                     ??PROTOCOLO_enviaPacote_2:
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \                     ??PROTOCOLO_enviaPacote_0:
   \   00000042   0x0001             MOVS     R1,R0
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0x42A9             CMP      R1,R5
   \   0000004C   0xD20E             BCS.N    ??PROTOCOLO_enviaPacote_3
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x5D01             LDRB     R1,[R0, R4]
   \   00000052   0x2910             CMP      R1,#+16
   \   00000054   0xD1EE             BNE.N    ??PROTOCOLO_enviaPacote_1
   \   00000056   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000058   0x....             LDR.N    R1,??DataTable6_4
   \   0000005A   0x2210             MOVS     R2,#+16
   \   0000005C   0x5472             STRB     R2,[R6, R1]
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \   00000060   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000062   0x....             LDR.N    R1,??DataTable6_4
   \   00000064   0x2210             MOVS     R2,#+16
   \   00000066   0x5472             STRB     R2,[R6, R1]
   \   00000068   0x1C76             ADDS     R6,R6,#+1
   \   0000006A   0xE7E9             B.N      ??PROTOCOLO_enviaPacote_2
    250            
    251            PROTOCOLO_bufferTx[indice++] = DLE;
   \                     ??PROTOCOLO_enviaPacote_3:
   \   0000006C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006E   0x....             LDR.N    R0,??DataTable6_4
   \   00000070   0x2110             MOVS     R1,#+16
   \   00000072   0x5431             STRB     R1,[R6, R0]
   \   00000074   0x1C76             ADDS     R6,R6,#+1
    252            PROTOCOLO_bufferTx[indice++] = ETX;
   \   00000076   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000078   0x....             LDR.N    R0,??DataTable6_4
   \   0000007A   0x2103             MOVS     R1,#+3
   \   0000007C   0x5431             STRB     R1,[R6, R0]
   \   0000007E   0x1C76             ADDS     R6,R6,#+1
    253            
    254            PROTOCOLO_bytesParaEnviar = indice-1;
   \   00000080   0x1E70             SUBS     R0,R6,#+1
   \   00000082   0x....             LDR.N    R1,??DataTable6_2
   \   00000084   0x7008             STRB     R0,[R1, #+0]
    255            PROTOCOLO_bytesEnviados = 1;
   \   00000086   0x....             LDR.N    R0,??DataTable6_3
   \   00000088   0x2101             MOVS     R1,#+1
   \   0000008A   0x7001             STRB     R1,[R0, #+0]
    256            U3THR = PROTOCOLO_bufferTx[0];  
   \   0000008C   0x....             LDR.N    R0,??DataTable6_5  ;; 0x4009c000
   \   0000008E   0x....             LDR.N    R1,??DataTable6_4
   \   00000090   0x7809             LDRB     R1,[R1, #+0]
   \   00000092   0x7001             STRB     R1,[R0, #+0]
    257          }
   \   00000094   0xBD70             POP      {R4-R6,PC}       ;; return
   \   00000096                      REQUIRE U3RBRTHR
    258          /***********************************************************************************
    259          *       Descrição       :       Verifica se o buffer de transmissão está vazio
    260          *       Parametros      :       nenhum
    261          *       Retorno         :       Tamanho do buffer de transmissão
    262          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    263          unsigned short int PROTOCOLO_bytesNoBufferTx(void){
    264            
    265            return PROTOCOLO_bytesParaEnviar;
   \                     PROTOCOLO_bytesNoBufferTx:
   \   00000000   0x....             LDR.N    R0,??DataTable6_2
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000006   0x4770             BX       LR               ;; return
    266          }
    267          /***********************************************************************************
    268          *       Descrição       :       envia data direto
    269          *       Parametros      :       nenhum
    270          *       Retorno         :       nenhum
    271          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    272          void PROTOCOLO_enviaDadosDireto(unsigned char *buffer,unsigned char tamanho){
   \                     PROTOCOLO_enviaDadosDireto:
   \   00000000   0xB410             PUSH     {R4}
    273            
    274            for(unsigned char i=0;i<tamanho;i++)
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xE005             B.N      ??PROTOCOLO_enviaDadosDireto_0
    275              PROTOCOLO_bufferTx[i] = buffer[i];
   \                     ??PROTOCOLO_enviaDadosDireto_1:
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x5C13             LDRB     R3,[R2, R0]
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x....             LDR.N    R4,??DataTable6_4
   \   0000000E   0x5513             STRB     R3,[R2, R4]
   \   00000010   0x1C52             ADDS     R2,R2,#+1
   \                     ??PROTOCOLO_enviaDadosDireto_0:
   \   00000012   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x428A             CMP      R2,R1
   \   00000018   0xD3F5             BCC.N    ??PROTOCOLO_enviaDadosDireto_1
    276            
    277            PROTOCOLO_bytesParaEnviar = tamanho-1;
   \   0000001A   0x1E49             SUBS     R1,R1,#+1
   \   0000001C   0x....             LDR.N    R2,??DataTable6_2
   \   0000001E   0x7011             STRB     R1,[R2, #+0]
    278            PROTOCOLO_bytesEnviados = 1;
   \   00000020   0x....             LDR.N    R1,??DataTable6_3
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x700A             STRB     R2,[R1, #+0]
    279            U3THR = buffer[0];    
   \   00000026   0x....             LDR.N    R1,??DataTable6_5  ;; 0x4009c000
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
    280          }
   \   0000002C   0xBC10             POP      {R4}
   \   0000002E   0x4770             BX       LR               ;; return
   \   00000030                      REQUIRE U3RBRTHR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x0001D1A0         DC32     0x1d1a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x4009C008         DC32     0x4009c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     PROTOCOLO_bytesParaEnviar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     PROTOCOLO_bytesEnviados

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     PROTOCOLO_bufferTx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x4009C000         DC32     0x4009c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     ??ultimoRecebido

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     PROTOCOLO_bytesRecebidos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x........         DC32     PROTOCOLO_bufferRx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x........         DC32     PROTOCOLO_novoPacote

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x4009C014         DC32     0x4009c014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x........         DC32     PROTOCOLO_bufferTmp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x........         DC32     `?<Constant "MPG2-2.1.0-BR-MA">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x........         DC32     PROTOCOLO_bufferTmp+0x3

   \                                 In section .rodata, align 4
   \                     `?<Constant "MPG2-2.1.0-BR-MA">`:
   \   00000000   0x4D 0x50          DC8 "MPG2-2.1.0-BR-MA"
   \              0x47 0x32    
   \              0x2D 0x32    
   \              0x2E 0x31    
   \              0x2E 0x30    
   \              0x2D 0x42    
   \              0x52 0x2D    
   \              0x4D 0x41    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    281          /***********************************************************************************
    282          *       Fim do arquivo
    283          ***********************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   PROTOCOLO_bytesNoBufferTx
       4   PROTOCOLO_checksum
       4   PROTOCOLO_enviaDadosDireto
      16   PROTOCOLO_enviaPacote
        16   -> PROTOCOLO_checksum
       8   PROTOCOLO_get_device
         8   -> PROTOCOLO_enviaPacote
         8   -> sprintf
       8   PROTOCOLO_ini
         8   -> UART_init
       0   PROTOCOLO_intVect
       8   PROTOCOLO_main
         8   -> PROTOCOLO_checksum
         8   -> PROTOCOLO_get_device
         8   -> PROTOCOLO_ini
         8   -> vTaskDelay
       0   PROTOCOLO_timerTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "MPG2-2.1.0-BR-MA">
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
     128  PROTOCOLO_bufferRx
    1024  PROTOCOLO_bufferTmp
    1024  PROTOCOLO_bufferTx
       1  PROTOCOLO_bytesEnviados
       8  PROTOCOLO_bytesNoBufferTx
       1  PROTOCOLO_bytesParaEnviar
       1  PROTOCOLO_bytesRecebidos
      32  PROTOCOLO_checksum
      48  PROTOCOLO_enviaDadosDireto
     150  PROTOCOLO_enviaPacote
      32  PROTOCOLO_get_device
      20  PROTOCOLO_ini
     312  PROTOCOLO_intVect
     112  PROTOCOLO_main
       1  PROTOCOLO_novoPacote
       2  PROTOCOLO_timerTick
       1  U3RBRTHR
       4  _A_CLRPEND0
       4  _A_U3FCR
       1  _A_U3LSR
       1  ultimoRecebido

 
 2 181 bytes in section .bss
    10 bytes in section .noinit (abs)
    20 bytes in section .rodata
   776 bytes in section .text
 
   776 bytes of CODE  memory
    20 bytes of CONST memory
 2 181 bytes of DATA  memory (+ 10 bytes shared)

Errors: none
Warnings: none
