###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      07/Jul/2017  16:29:07 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Drivers\Protocolo\Protocolo.c             #
#    Command line =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Drivers\Protocolo\Protocolo.c -lC         #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\ -lA                           #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\ -o                            #
#                    C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\Obj\ --no_cse --no_unroll           #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -Ol                                               #
#    List file    =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\List\Protocolo.lst                  #
#    Object file  =  C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPip #
#                    ocaG2\SOFTWARE\Debug\Obj\Protocolo.o                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Marcos\Dropbox\Reps\Dextro\IBA\Hardware\MaisPipocaG2\SOFTWARE\Drivers\Protocolo\Protocolo.c
      1          /*__________________________________________________________________________________
      2          |	Quark Tecnologia Eletrônica Embarcada
      3          |       
      4          |       Itapema - SC
      5          |       www.quarktee.com.br
      6          | __________________________________________________________________________________
      7          |
      8          |       This source code was developed by Quark  and cannot be copied, in part 
      9          |       or in whole, or used, except when legally licensed by Quark 
     10          |       or its distributors.
     11          |
     12          |       Este código é propriedade da Quark  e não pode ser copiado, em parte 
     13          |       ou em todo, ou utilizado, exceto quando for legalmente licenciado pela 
     14          |       Quark  ou por um de seus distribuidores.
     15          | __________________________________________________________________________________
     16          |
     17          |       Arquivo            :  Protocolo.c
     18          | 
     19          |       Autor              :  Marcos Aquino
     20          |       Data criação       :  21/02/2014
     21          |
     22          |       Revisões           :  1.0.0.0
     23          |
     24          |
     25          | __________________________________________________________________________________
     26          */
     27          
     28          /***********************************************************************************
     29          *       Includes
     30          ***********************************************************************************/
     31          #include <nxp\iolpc1768.h>

   \                                 In section .noinit, at 0xe000e280
   \   __absolute union <unnamed> volatile _A_CLRPEND0
   \                     _A_CLRPEND0:
   \   00000000                      DS8 4

   \                                 In section .noinit, at 0x4009c000
   \   __absolute unsigned char volatile U3RBRTHR
   \                     U3RBRTHR:
   \   00000000                      DS8 1

   \                                 In section .noinit, at 0x4009c008
   \   __absolute union <unnamed> volatile _A_U3FCR
   \                     _A_U3FCR:
   \   00000000                      DS8 4

   \                                 In section .noinit, at 0x4009c014
   \   __absolute union <unnamed> const volatile _A_U3LSR
   \                     _A_U3LSR:
   \   00000000                      DS8 1
     32          #include "protocolo.h"
     33          #include "..\..\includes.h"
     34          
     35          /***********************************************************************************
     36          *       Definições locais
     37          ***********************************************************************************/
     38          #define TAM_BUF_TX                              1024
     39          #define TAM_BUF_RX                              128
     40          
     41          #define STX                                     0x02
     42          #define ETX                                     0x03
     43          #define DLE                                     0x10
     44          
     45          /***********************************************************************************
     46          *       Variaveis locais
     47          ***********************************************************************************/

   \                                 In section .bss, align 4
     48          unsigned char PROTOCOLO_bufferTx[TAM_BUF_TX];
   \                     PROTOCOLO_bufferTx:
   \   00000000                      DS8 1024

   \                                 In section .bss, align 4
     49          unsigned char PROTOCOLO_bufferRx[TAM_BUF_RX];
   \                     PROTOCOLO_bufferRx:
   \   00000000                      DS8 128

   \                                 In section .bss, align 4
     50          unsigned char PROTOCOLO_bufferTmp[TAM_BUF_TX];
   \                     PROTOCOLO_bufferTmp:
   \   00000000                      DS8 1024

   \                                 In section .bss, align 1
     51          unsigned char PROTOCOLO_bytesRecebidos;
   \                     PROTOCOLO_bytesRecebidos:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     52          unsigned char PROTOCOLO_bytesParaEnviar;
   \                     PROTOCOLO_bytesParaEnviar:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     53          unsigned char PROTOCOLO_bytesEnviados;
   \                     PROTOCOLO_bytesEnviados:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     54          unsigned char PROTOCOLO_novoPacote=0;
   \                     PROTOCOLO_novoPacote:
   \   00000000                      DS8 1
     55          
     56          
     57          /***********************************************************************************
     58          *       Funções locais
     59          ***********************************************************************************/
     60          void PROTOCOLO_enviaPacote(unsigned char *pData,unsigned short int tamanho);
     61          unsigned char PROTOCOLO_checksum(unsigned char*pData,unsigned short int tamanho);
     62          void PROTOCOLO_decodeLeBloco(unsigned long int endereco,unsigned char tamanho);
     63          void PROTOCOLO_decodeEscreveBloco(unsigned long int endereco,unsigned char tamanho,unsigned char *dados);
     64          void PROTOCOLO_decodeFormataAudioFlash(void);
     65          void PROTOCOLO_decodeEscreveTabelaMusicas(unsigned char musica,
     66                                                    unsigned long int enderecoInicial,
     67                                                    unsigned long int tamanho);
     68          void PROTOCOLO_decodeLeituraTabelaMusicas(unsigned char musica);
     69          void PROTOCOLO_decodeEscreveParametro(unsigned char indice,unsigned short int valor);
     70          void PROTOCOLO_decodeLeParametro(unsigned char indice);
     71          void PROTOCOLO_decodeMensagemUsuario(unsigned char indice,unsigned char *msg);
     72          void PROTOCOLO_decodeAssinaPlaca(void);
     73          void PROTOCOLO_decodifica_tamanho_parametros(void);
     74          void PROTOCOLO_decodifica_info_sobre_parametro(unsigned short int parametro);
     75          void PROTOCOLO_decodifica_leitura_valor_parametro(unsigned short int parametro);
     76          void PROTOCOLO_decodifica_escrita_valor_parametro(unsigned short int parametro,
     77                                                            unsigned char tipo,
     78                                                            unsigned char *valor);
     79          
     80          /***********************************************************************************
     81          *       Implementação das funções
     82          ***********************************************************************************/
     83          
     84          /***********************************************************************************
     85          *       Descrição       :       Inicialização da biblioteca
     86          *       Parametros      :       nenhum
     87          *       Retorno         :       nenhum
     88          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     89          void PROTOCOLO_ini(void){
   \                     PROTOCOLO_ini:
   \   00000000   0xB580             PUSH     {R7,LR}
     90            
     91            UART_init(3,36600,NULL,NULL,NULL);    
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xF648 0x61F8      MOVW     R1,#+36600
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x.... 0x....      BL       UART_init
     92          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
     93          /***********************************************************************************
     94          *       Descrição       :       Função para tratamento da interrupção
     95          *                               da uart3
     96          *       Parametros      :       nenhum
     97          *       Retorno         :       nenhum
     98          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     99          void PROTOCOLO_intVect(void){  
    100            static unsigned char ultimoRecebido=0;
    101            unsigned char dummy;
    102            
    103            switch(U3IIR_bit.IID){
   \                     PROTOCOLO_intVect:
   \   00000000   0x....             LDR.N    R0,??DataTable2  ;; 0x4009c008
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0840             LSRS     R0,R0,#+1
   \   00000006   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD008             BEQ.N    ??PROTOCOLO_intVect_0
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD01B             BEQ.N    ??PROTOCOLO_intVect_1
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xF000 0x8083      BEQ.W    ??PROTOCOLO_intVect_2
   \   00000018   0x2806             CMP      R0,#+6
   \   0000001A   0xF000 0x8086      BEQ.W    ??PROTOCOLO_intVect_3
   \   0000001E   0xE084             B.N      ??PROTOCOLO_intVect_4
    104              case THRE:
    105                         if(PROTOCOLO_bytesParaEnviar){
   \                     ??PROTOCOLO_intVect_0:
   \   00000020   0x....             LDR.N    R0,??DataTable2_1
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD00F             BEQ.N    ??PROTOCOLO_intVect_5
    106                           U3THR = PROTOCOLO_bufferTx[PROTOCOLO_bytesEnviados++];
   \   00000028   0x....             LDR.N    R0,??DataTable2_2
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x....             LDR.N    R1,??DataTable2_3
   \   0000002E   0x5C40             LDRB     R0,[R0, R1]
   \   00000030   0x....             LDR.N    R1,??DataTable2_4  ;; 0x4009c000
   \   00000032   0x7008             STRB     R0,[R1, #+0]
   \   00000034   0x....             LDR.N    R0,??DataTable2_2
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0x....             LDR.N    R1,??DataTable2_2
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
    107                           PROTOCOLO_bytesParaEnviar--;
   \   0000003E   0x....             LDR.N    R0,??DataTable2_1
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   \   00000044   0x....             LDR.N    R1,??DataTable2_1
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    108                         }
    109                         break; 
   \                     ??PROTOCOLO_intVect_5:
   \   00000048   0xE06F             B.N      ??PROTOCOLO_intVect_4
    110              case RDA : dummy = U3RBR;
   \                     ??PROTOCOLO_intVect_1:
   \   0000004A   0x....             LDR.N    R0,??DataTable2_4  ;; 0x4009c000
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
    111                         switch(dummy){
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x0001             MOVS     R1,R0
   \   00000052   0x2902             CMP      R1,#+2
   \   00000054   0xD004             BEQ.N    ??PROTOCOLO_intVect_6
   \   00000056   0x2903             CMP      R1,#+3
   \   00000058   0xD01E             BEQ.N    ??PROTOCOLO_intVect_7
   \   0000005A   0x2910             CMP      R1,#+16
   \   0000005C   0xD038             BEQ.N    ??PROTOCOLO_intVect_8
   \   0000005E   0xE050             B.N      ??PROTOCOLO_intVect_9
    112                           case STX: // Quando receber [DLE]+[STX] - marca inicio de novo pacote
    113                                     if(ultimoRecebido == DLE){
   \                     ??PROTOCOLO_intVect_6:
   \   00000060   0x....             LDR.N    R1,??DataTable2_5
   \   00000062   0x7809             LDRB     R1,[R1, #+0]
   \   00000064   0x2910             CMP      R1,#+16
   \   00000066   0xD106             BNE.N    ??PROTOCOLO_intVect_10
    114                                       PROTOCOLO_bytesRecebidos = 0;
   \   00000068   0x....             LDR.N    R0,??DataTable2_6
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x7001             STRB     R1,[R0, #+0]
    115                                       ultimoRecebido = 255;
   \   0000006E   0x....             LDR.N    R0,??DataTable2_5
   \   00000070   0x21FF             MOVS     R1,#+255
   \   00000072   0x7001             STRB     R1,[R0, #+0]
   \   00000074   0xE00F             B.N      ??PROTOCOLO_intVect_11
    116                                     }
    117                                     else{
    118                                       if(PROTOCOLO_bytesRecebidos<(TAM_BUF_RX-1)) 
   \                     ??PROTOCOLO_intVect_10:
   \   00000076   0x....             LDR.N    R1,??DataTable2_6
   \   00000078   0x7809             LDRB     R1,[R1, #+0]
   \   0000007A   0x297F             CMP      R1,#+127
   \   0000007C   0xDA08             BGE.N    ??PROTOCOLO_intVect_12
    119                                         PROTOCOLO_bufferRx[PROTOCOLO_bytesRecebidos++] = dummy;                                                         
   \   0000007E   0x....             LDR.N    R1,??DataTable2_6
   \   00000080   0x7809             LDRB     R1,[R1, #+0]
   \   00000082   0x....             LDR.N    R2,??DataTable2_7
   \   00000084   0x5488             STRB     R0,[R1, R2]
   \   00000086   0x....             LDR.N    R0,??DataTable2_6
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
   \   0000008C   0x....             LDR.N    R1,??DataTable2_6
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
    120                                       
    121                                       ultimoRecebido = STX;
   \                     ??PROTOCOLO_intVect_12:
   \   00000090   0x....             LDR.N    R0,??DataTable2_5
   \   00000092   0x2102             MOVS     R1,#+2
   \   00000094   0x7001             STRB     R1,[R0, #+0]
    122                                     }
    123                                     
    124                                     break;
   \                     ??PROTOCOLO_intVect_11:
   \   00000096   0xE041             B.N      ??PROTOCOLO_intVect_13
    125                           case ETX: // Quando receber [DLE]+[ETX] - marca fim do novo pacote
    126                                     if(ultimoRecebido == DLE){
   \                     ??PROTOCOLO_intVect_7:
   \   00000098   0x....             LDR.N    R1,??DataTable2_5
   \   0000009A   0x7809             LDRB     R1,[R1, #+0]
   \   0000009C   0x2910             CMP      R1,#+16
   \   0000009E   0xD106             BNE.N    ??PROTOCOLO_intVect_14
    127                                       PROTOCOLO_novoPacote = 255;
   \   000000A0   0x....             LDR.N    R0,??DataTable2_8
   \   000000A2   0x21FF             MOVS     R1,#+255
   \   000000A4   0x7001             STRB     R1,[R0, #+0]
    128                                       ultimoRecebido = 255;
   \   000000A6   0x....             LDR.N    R0,??DataTable2_5
   \   000000A8   0x21FF             MOVS     R1,#+255
   \   000000AA   0x7001             STRB     R1,[R0, #+0]
   \   000000AC   0xE00F             B.N      ??PROTOCOLO_intVect_15
    129                                     }
    130                                     else{
    131                                       if(PROTOCOLO_bytesRecebidos<(TAM_BUF_RX-1)) 
   \                     ??PROTOCOLO_intVect_14:
   \   000000AE   0x....             LDR.N    R1,??DataTable2_6
   \   000000B0   0x7809             LDRB     R1,[R1, #+0]
   \   000000B2   0x297F             CMP      R1,#+127
   \   000000B4   0xDA08             BGE.N    ??PROTOCOLO_intVect_16
    132                                         PROTOCOLO_bufferRx[PROTOCOLO_bytesRecebidos++] = dummy;                                                         
   \   000000B6   0x....             LDR.N    R1,??DataTable2_6
   \   000000B8   0x7809             LDRB     R1,[R1, #+0]
   \   000000BA   0x....             LDR.N    R2,??DataTable2_7
   \   000000BC   0x5488             STRB     R0,[R1, R2]
   \   000000BE   0x....             LDR.N    R0,??DataTable2_6
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0x1C40             ADDS     R0,R0,#+1
   \   000000C4   0x....             LDR.N    R1,??DataTable2_6
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
    133                                       
    134                                       ultimoRecebido = ETX;
   \                     ??PROTOCOLO_intVect_16:
   \   000000C8   0x....             LDR.N    R0,??DataTable2_5
   \   000000CA   0x2103             MOVS     R1,#+3
   \   000000CC   0x7001             STRB     R1,[R0, #+0]
    135                                     }                   
    136                                     break;
   \                     ??PROTOCOLO_intVect_15:
   \   000000CE   0xE025             B.N      ??PROTOCOLO_intVect_13
    137                           case DLE: // Quando receber [DLE]+[DLE] recebe 0x10 dentro do buffer
    138                                     if(ultimoRecebido == DLE){
   \                     ??PROTOCOLO_intVect_8:
   \   000000D0   0x....             LDR.N    R1,??DataTable2_5
   \   000000D2   0x7809             LDRB     R1,[R1, #+0]
   \   000000D4   0x2910             CMP      R1,#+16
   \   000000D6   0xD110             BNE.N    ??PROTOCOLO_intVect_17
    139                                       if(PROTOCOLO_bytesRecebidos<(TAM_BUF_RX-1))
   \   000000D8   0x....             LDR.N    R1,??DataTable2_6
   \   000000DA   0x7809             LDRB     R1,[R1, #+0]
   \   000000DC   0x297F             CMP      R1,#+127
   \   000000DE   0xDA08             BGE.N    ??PROTOCOLO_intVect_18
    140                                         PROTOCOLO_bufferRx[PROTOCOLO_bytesRecebidos++] = dummy;
   \   000000E0   0x....             LDR.N    R1,??DataTable2_6
   \   000000E2   0x7809             LDRB     R1,[R1, #+0]
   \   000000E4   0x....             LDR.N    R2,??DataTable2_7
   \   000000E6   0x5488             STRB     R0,[R1, R2]
   \   000000E8   0x....             LDR.N    R0,??DataTable2_6
   \   000000EA   0x7800             LDRB     R0,[R0, #+0]
   \   000000EC   0x1C40             ADDS     R0,R0,#+1
   \   000000EE   0x....             LDR.N    R1,??DataTable2_6
   \   000000F0   0x7008             STRB     R0,[R1, #+0]
    141                                       ultimoRecebido = 255;
   \                     ??PROTOCOLO_intVect_18:
   \   000000F2   0x....             LDR.N    R0,??DataTable2_5
   \   000000F4   0x21FF             MOVS     R1,#+255
   \   000000F6   0x7001             STRB     R1,[R0, #+0]
   \   000000F8   0xE002             B.N      ??PROTOCOLO_intVect_19
    142                                     }                      
    143                                     else
    144                                       ultimoRecebido = DLE;
   \                     ??PROTOCOLO_intVect_17:
   \   000000FA   0x....             LDR.N    R0,??DataTable2_5
   \   000000FC   0x2110             MOVS     R1,#+16
   \   000000FE   0x7001             STRB     R1,[R0, #+0]
    145                                     break;
   \                     ??PROTOCOLO_intVect_19:
   \   00000100   0xE00C             B.N      ??PROTOCOLO_intVect_13
    146                           default :
    147                                     if(PROTOCOLO_bytesRecebidos<(TAM_BUF_RX-1)) 
   \                     ??PROTOCOLO_intVect_9:
   \   00000102   0x....             LDR.N    R1,??DataTable2_6
   \   00000104   0x7809             LDRB     R1,[R1, #+0]
   \   00000106   0x297F             CMP      R1,#+127
   \   00000108   0xDA08             BGE.N    ??PROTOCOLO_intVect_20
    148                                       PROTOCOLO_bufferRx[PROTOCOLO_bytesRecebidos++] = dummy;                                                                            
   \   0000010A   0x....             LDR.N    R1,??DataTable2_6
   \   0000010C   0x7809             LDRB     R1,[R1, #+0]
   \   0000010E   0x....             LDR.N    R2,??DataTable2_7
   \   00000110   0x5488             STRB     R0,[R1, R2]
   \   00000112   0x....             LDR.N    R0,??DataTable2_6
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0x1C40             ADDS     R0,R0,#+1
   \   00000118   0x....             LDR.N    R1,??DataTable2_6
   \   0000011A   0x7008             STRB     R0,[R1, #+0]
    149                                     break;
    150                         }
    151                         
    152                         //ultimoRecebido = dummy;
    153                         break;      
   \                     ??PROTOCOLO_intVect_20:
   \                     ??PROTOCOLO_intVect_13:
   \   0000011C   0xE005             B.N      ??PROTOCOLO_intVect_4
    154              case RLS : 
    155                         dummy = U3LSR;
   \                     ??PROTOCOLO_intVect_2:
   \   0000011E   0x....             LDR.N    R0,??DataTable2_9  ;; 0x4009c014
   \   00000120   0x7800             LDRB     R0,[R0, #+0]
    156                         dummy = U3RBR;               
   \   00000122   0x....             LDR.N    R1,??DataTable2_4  ;; 0x4009c000
   \   00000124   0x7809             LDRB     R1,[R1, #+0]
   \   00000126   0x0008             MOVS     R0,R1
    157                         break;      
   \   00000128   0xE7FF             B.N      ??PROTOCOLO_intVect_4
    158              case CTI :
    159                         break;      
    160            }  
    161            
    162            //Apaga o flag de interrupção pendente
    163            CLRPEND0 |= (0x01)<<5;       
   \                     ??PROTOCOLO_intVect_3:
   \                     ??PROTOCOLO_intVect_4:
   \   0000012A   0x....             LDR.N    R0,??DataTable2_10  ;; 0xe000e280
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000132   0x....             LDR.N    R1,??DataTable2_10  ;; 0xe000e280
   \   00000134   0x6008             STR      R0,[R1, #+0]
    164          }
   \   00000136   0x4770             BX       LR               ;; return
   \   00000138                      REQUIRE U3RBRTHR
   \   00000138                      REQUIRE _A_U3LSR
   \   00000138                      REQUIRE _A_U3FCR
   \   00000138                      REQUIRE _A_CLRPEND0

   \                                 In section .bss, align 1
   \                     ??ultimoRecebido:
   \   00000000                      DS8 1
    165          /***********************************************************************************
    166          *       Descrição       :       Tick de timer para a biblioteca do protocolo
    167          *       Parametros      :       nenhum
    168          *       Retorno         :       nenhum
    169          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    170          void PROTOCOLO_timerTick(void){
    171            
    172            
    173            
    174          }
   \                     PROTOCOLO_timerTick:
   \   00000000   0x4770             BX       LR               ;; return
    175          /***********************************************************************************
    176          *       Descrição       :       Calcula o checksum de um pacote de dados
    177          *       Parametros      :       (unsigned char*) ponteiro para o início do pacote
    178          *                               (unsigned short int) tamanho do pacote
    179          *       Retorno         :       (unsigned char) checksum do pacote
    180          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    181          unsigned char PROTOCOLO_checksum(unsigned char*pData,unsigned short int tamanho){
   \                     PROTOCOLO_checksum:
   \   00000000   0xB410             PUSH     {R4}
    182            unsigned short int soma=0;
   \   00000002   0x2200             MOVS     R2,#+0
    183          
    184            for(unsigned short int i=0;i<tamanho;i++)
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0xE003             B.N      ??PROTOCOLO_checksum_0
    185              soma+= pData[i];
   \                     ??PROTOCOLO_checksum_1:
   \   00000008   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000000A   0x5C1C             LDRB     R4,[R3, R0]
   \   0000000C   0x18A2             ADDS     R2,R4,R2
   \   0000000E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??PROTOCOLO_checksum_0:
   \   00000010   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000012   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000014   0x428B             CMP      R3,R1
   \   00000016   0xD3F7             BCC.N    ??PROTOCOLO_checksum_1
    186            
    187            return (unsigned char)(256-soma);    
   \   00000018   0x4250             RSBS     R0,R2,#+0
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
    188          }
    189          /***********************************************************************************
    190          *       Descrição       :       Thread do protocolo
    191          *       Protocolo       :       (void*) pPar
    192          *       Retorno         :       nenhum
    193          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    194          void PROTOCOLO_main(void*pPar){
   \                     PROTOCOLO_main:
   \   00000000   0xB580             PUSH     {R7,LR}
    195            
    196            PROTOCOLO_ini();
   \   00000002   0x.... 0x....      BL       PROTOCOLO_ini
    197            //WATCHDOG_init(0);  
    198            
    199            for(;;){
    200                  
    201              //FEEDS_THE_DOG();
    202              
    203              if(PROTOCOLO_novoPacote){
    204                /*
    205                PROTOCOLO_novoPacote = 0;        
    206                if(PROTOCOLO_checksum(PROTOCOLO_bufferRx,PROTOCOLO_bufferRx[1]-1)==PROTOCOLO_bufferRx[PROTOCOLO_bytesRecebidos-1]){      
    207                  switch(PROTOCOLO_bufferRx[0]){
    208                   case READ_DATA_FLASH_BLOCK:              
    209                        PROTOCOLO_decodeLeBloco     (PROTOCOLO_bufferRx[2]<<24 | PROTOCOLO_bufferRx[3]<<16 | PROTOCOLO_bufferRx[4]<<8 | PROTOCOLO_bufferRx[5],PROTOCOLO_bufferRx[6]);
    210                        break;
    211                   case WRITE_DATA_FLASH_BLOCK:
    212                        PROTOCOLO_decodeEscreveBloco(PROTOCOLO_bufferRx[2]<<24 | PROTOCOLO_bufferRx[3]<<16 | PROTOCOLO_bufferRx[4]<<8 | PROTOCOLO_bufferRx[5],PROTOCOLO_bufferRx[6],&PROTOCOLO_bufferRx[7]);
    213                        break;
    214                   case FORMAT_AUDIO_FLASH:
    215                        PROTOCOLO_decodeFormataAudioFlash();
    216                        break;
    217                   case WRITE_MUSIC_TABLE:
    218                        PROTOCOLO_decodeEscreveTabelaMusicas(PROTOCOLO_bufferRx[2],
    219                                                             PROTOCOLO_bufferRx[3]<<16 | PROTOCOLO_bufferRx[4]<<8 | PROTOCOLO_bufferRx[5],
    220                                                             PROTOCOLO_bufferRx[6]<<16 | PROTOCOLO_bufferRx[7]<<8 | PROTOCOLO_bufferRx[8]);
    221                        break;
    222                   case READ_MUSIC_TABLE:
    223                        PROTOCOLO_decodeLeituraTabelaMusicas(PROTOCOLO_bufferRx[2]);
    224                        break;          
    225                   case GET_PARAMETERS_LENGHT:
    226                        PROTOCOLO_decodifica_tamanho_parametros();
    227                        break;
    228                   case GET_PARAMETER_INFO:
    229                        PROTOCOLO_decodifica_info_sobre_parametro(PROTOCOLO_bufferRx[2]<<8 | PROTOCOLO_bufferRx[3]);
    230                        break;
    231                   case GET_PARAMETER_DATA:
    232                        PROTOCOLO_decodifica_leitura_valor_parametro(PROTOCOLO_bufferRx[2]<<8 | PROTOCOLO_bufferRx[3]);
    233                        break;
    234                   case SET_PARAMETER_DATA:
    235                        PROTOCOLO_decodifica_escrita_valor_parametro(PROTOCOLO_bufferRx[2]<<8 | PROTOCOLO_bufferRx[3],
    236                                                                     PROTOCOLO_bufferRx[4],
    237                                                                    &PROTOCOLO_bufferRx[5]);
    238                        break;
    239                  }
    240                */
    241                //}      
    242              }
    243              vTaskDelay(1);
   \                     ??PROTOCOLO_main_0:
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       vTaskDelay
   \   0000000C   0xE7FB             B.N      ??PROTOCOLO_main_0
    244            }    
    245          }
    246          /***********************************************************************************
    247          *       Descrição       :       Encapsula os dados que serão enviados
    248          *                               pela rede
    249          *       Parametros      :       (unsigned char*) ponteiro para os dados que serão
    250          *                                               enviados
    251          *       Retorno         :       nenhum
    252          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    253          void PROTOCOLO_enviaPacote(unsigned char *pData,unsigned short int tamanho){
   \                     PROTOCOLO_enviaPacote:
   \   00000000   0xB430             PUSH     {R4,R5}
    254            unsigned char indice=0;
   \   00000002   0x2200             MOVS     R2,#+0
    255            
    256            PROTOCOLO_bufferTx[indice++] = DLE;
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0x....             LDR.N    R3,??DataTable2_3
   \   00000008   0x2410             MOVS     R4,#+16
   \   0000000A   0x54D4             STRB     R4,[R2, R3]
   \   0000000C   0x1C52             ADDS     R2,R2,#+1
    257            PROTOCOLO_bufferTx[indice++] = STX;
   \   0000000E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000010   0x....             LDR.N    R3,??DataTable2_3
   \   00000012   0x2402             MOVS     R4,#+2
   \   00000014   0x54D4             STRB     R4,[R2, R3]
   \   00000016   0x1C52             ADDS     R2,R2,#+1
    258            for(unsigned char i=0;i<tamanho;i++)
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0xE006             B.N      ??PROTOCOLO_enviaPacote_0
    259              if(pData[i]==DLE){
    260                PROTOCOLO_bufferTx[indice++] = DLE;
    261                PROTOCOLO_bufferTx[indice++] = DLE;
    262              }
    263              else
    264                PROTOCOLO_bufferTx[indice++] = pData[i];
   \                     ??PROTOCOLO_enviaPacote_1:
   \   0000001C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001E   0x5C1C             LDRB     R4,[R3, R0]
   \   00000020   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000022   0x....             LDR.N    R5,??DataTable2_3
   \   00000024   0x5554             STRB     R4,[R2, R5]
   \   00000026   0x1C52             ADDS     R2,R2,#+1
   \                     ??PROTOCOLO_enviaPacote_2:
   \   00000028   0x1C5B             ADDS     R3,R3,#+1
   \                     ??PROTOCOLO_enviaPacote_0:
   \   0000002A   0x001C             MOVS     R4,R3
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000030   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000032   0x428C             CMP      R4,R1
   \   00000034   0xD20E             BCS.N    ??PROTOCOLO_enviaPacote_3
   \   00000036   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000038   0x5C1C             LDRB     R4,[R3, R0]
   \   0000003A   0x2C10             CMP      R4,#+16
   \   0000003C   0xD1EE             BNE.N    ??PROTOCOLO_enviaPacote_1
   \   0000003E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000040   0x....             LDR.N    R4,??DataTable2_3
   \   00000042   0x2510             MOVS     R5,#+16
   \   00000044   0x5515             STRB     R5,[R2, R4]
   \   00000046   0x1C52             ADDS     R2,R2,#+1
   \   00000048   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004A   0x....             LDR.N    R4,??DataTable2_3
   \   0000004C   0x2510             MOVS     R5,#+16
   \   0000004E   0x5515             STRB     R5,[R2, R4]
   \   00000050   0x1C52             ADDS     R2,R2,#+1
   \   00000052   0xE7E9             B.N      ??PROTOCOLO_enviaPacote_2
    265            
    266            PROTOCOLO_bufferTx[indice++] = DLE;
   \                     ??PROTOCOLO_enviaPacote_3:
   \   00000054   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000056   0x....             LDR.N    R0,??DataTable2_3
   \   00000058   0x2110             MOVS     R1,#+16
   \   0000005A   0x5411             STRB     R1,[R2, R0]
   \   0000005C   0x1C52             ADDS     R2,R2,#+1
    267            PROTOCOLO_bufferTx[indice++] = ETX;
   \   0000005E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000060   0x....             LDR.N    R0,??DataTable2_3
   \   00000062   0x2103             MOVS     R1,#+3
   \   00000064   0x5411             STRB     R1,[R2, R0]
   \   00000066   0x1C52             ADDS     R2,R2,#+1
    268            
    269            PROTOCOLO_bytesParaEnviar = indice-1;
   \   00000068   0x1E50             SUBS     R0,R2,#+1
   \   0000006A   0x....             LDR.N    R1,??DataTable2_1
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
    270            PROTOCOLO_bytesEnviados = 1;
   \   0000006E   0x....             LDR.N    R0,??DataTable2_2
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x7001             STRB     R1,[R0, #+0]
    271            U3THR = PROTOCOLO_bufferTx[0];  
   \   00000074   0x....             LDR.N    R0,??DataTable2_4  ;; 0x4009c000
   \   00000076   0x....             LDR.N    R1,??DataTable2_3
   \   00000078   0x7809             LDRB     R1,[R1, #+0]
   \   0000007A   0x7001             STRB     R1,[R0, #+0]
    272          }
   \   0000007C   0xBC30             POP      {R4,R5}
   \   0000007E   0x4770             BX       LR               ;; return
   \   00000080                      REQUIRE U3RBRTHR
    273          /***********************************************************************************
    274          *       Descrição       :       Lê um bloco de dados da dataflash
    275          *       Parametros      :       nenhum
    276          *       Retorno         :       nenhum
    277          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    278          void PROTOCOLO_decodeLeBloco(unsigned long int endereco,unsigned char tamanho){
    279                                 
    280            /*
    281            if(tamanho>128){     
    282              PROTOCOLO_bufferTmp[0] = READ_DATA_FLASH_BLOCK | 0x80;
    283              PROTOCOLO_bufferTmp[1] = 4;
    284              PROTOCOLO_bufferTmp[2] = 1;
    285              PROTOCOLO_bufferTmp[3] = PROTOCOLO_checksum(PROTOCOLO_bufferTmp,3);
    286              
    287              PROTOCOLO_enviaPacote(PROTOCOLO_bufferTmp,4);  
    288            }
    289            else{
    290              PROTOCOLO_bufferTmp[0] = READ_DATA_FLASH_BLOCK;
    291              PROTOCOLO_bufferTmp[1] = tamanho+8;
    292              PROTOCOLO_bufferTmp[2] = endereco>>24;
    293              PROTOCOLO_bufferTmp[3] = endereco>>16;
    294              PROTOCOLO_bufferTmp[4] = endereco>>8;
    295              PROTOCOLO_bufferTmp[5] = endereco;
    296              PROTOCOLO_bufferTmp[6] = tamanho;
    297             
    298              SST_highSpeedRead(endereco+AREA_AUDIO,&PROTOCOLO_bufferTmp[7],tamanho);
    299            
    300              PROTOCOLO_bufferTmp[7+tamanho] = PROTOCOLO_checksum(PROTOCOLO_bufferTmp,7+tamanho);
    301              PROTOCOLO_enviaPacote(PROTOCOLO_bufferTmp,tamanho+8);  
    302            }
    303            */
    304          }
   \                     PROTOCOLO_decodeLeBloco:
   \   00000000   0x4770             BX       LR               ;; return
    305          /***********************************************************************************
    306          *       Descrição       :       Escreve um bloco de dados
    307          *                               na memória de dados
    308          *       Parametros      :       (unsigned int) endereco inicial da escrita
    309          *                               (unsigned char) tamanho do bloco
    310          *                               (unsigned char*) ponteiro para os dados
    311          *       Retorno         :       nenhum
    312          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    313          void PROTOCOLO_decodeEscreveBloco(unsigned long int endereco,unsigned char tamanho,
    314                                            unsigned char *dados){
    315                                              /*
    316            
    317            if(tamanho>128){    
    318              PROTOCOLO_bufferTmp[0] = WRITE_DATA_FLASH_BLOCK | 0x80;
    319              PROTOCOLO_bufferTmp[1] = 4;
    320              PROTOCOLO_bufferTmp[2] = 1;
    321              PROTOCOLO_bufferTmp[3] = PROTOCOLO_checksum(PROTOCOLO_bufferTmp,3);
    322              
    323              PROTOCOLO_enviaPacote(PROTOCOLO_bufferTmp,4);      
    324            }
    325            else{
    326              PROTOCOLO_bufferTmp[0] = WRITE_DATA_FLASH_BLOCK;
    327              PROTOCOLO_bufferTmp[1] = 8;
    328              PROTOCOLO_bufferTmp[2] = endereco>>24;
    329              PROTOCOLO_bufferTmp[3] = endereco>>16;
    330              PROTOCOLO_bufferTmp[4] = endereco>>8;
    331              PROTOCOLO_bufferTmp[5] = endereco;
    332              PROTOCOLO_bufferTmp[6] = tamanho;
    333             
    334              SST_writeAutoAddressInc(endereco+AREA_AUDIO,dados,tamanho);
    335            
    336              PROTOCOLO_bufferTmp[7] = PROTOCOLO_checksum(PROTOCOLO_bufferTmp,7);
    337              PROTOCOLO_enviaPacote(PROTOCOLO_bufferTmp,8);  
    338            }      
    339                                              */
    340          }
   \                     PROTOCOLO_decodeEscreveBloco:
   \   00000000   0x4770             BX       LR               ;; return
    341          /***********************************************************************************
    342          *       Descrição       :      Formata a área da flash onde são alocados
    343          *                              os arquivos de audio
    344          *       Parametros      :      nenhum
    345          *       Retorno         :      nenhum
    346          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    347          void PROTOCOLO_decodeFormataAudioFlash(void){
    348            /*
    349            unsigned long int enderecoInicial=AREA_AUDIO;
    350            
    351            for(unsigned short int i=0;i<599;i++){
    352              SST_erase4kbSector(enderecoInicial);
    353              enderecoInicial+=4096;
    354              //FEEDS_THE_DOG();
    355            }
    356              
    357            PROTOCOLO_bufferTmp[0] = FORMAT_AUDIO_FLASH;
    358            PROTOCOLO_bufferTmp[1] = 3;
    359            PROTOCOLO_bufferTmp[2] = PROTOCOLO_checksum(PROTOCOLO_bufferTmp,2);
    360            
    361            PROTOCOLO_enviaPacote(PROTOCOLO_bufferTmp,3);  
    362            */
    363          }
   \                     PROTOCOLO_decodeFormataAudioFlash:
   \   00000000   0x4770             BX       LR               ;; return
    364          /***********************************************************************************
    365          *       Descrição       :       Escreve valores na tabela de musica do sistema
    366          *       Parametros      :       (unsigned char) música
    367          *                               (unsigned long int) endereco inicial
    368          *                               (unsigned long int) tamanho da música
    369          *       Retorno         :       nenhum
    370          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    371          void PROTOCOLO_decodeEscreveTabelaMusicas(unsigned char musica,
    372                                                    unsigned long int enderecoInicial,
    373                                                    unsigned long int tamanho){
    374                                                      
    375                                                      /*
    376            if(musica>3){
    377              PROTOCOLO_bufferTmp[0] = WRITE_MUSIC_TABLE | 0x80;
    378              PROTOCOLO_bufferTmp[1] = 4;
    379              PROTOCOLO_bufferTmp[2] = 1;
    380              PROTOCOLO_bufferTmp[3] = PROTOCOLO_checksum(PROTOCOLO_bufferTmp,3);
    381              
    382              PROTOCOLO_enviaPacote(PROTOCOLO_bufferTmp,4);                                                    
    383            } 
    384            else{
    385              
    386              unsigned int temp;
    387              
    388              temp = enderecoInicial + AREA_AUDIO;
    389              PARAMETROS_grava(ADR_INICIO_BLOCO_MUSICA+musica,(void*)&temp);
    390              
    391              temp = tamanho;
    392              PARAMETROS_grava(ADR_TAMANHO_BLOCO_MUSICA+musica,(void*)&temp);
    393              
    394              PROTOCOLO_bufferTmp[0] = WRITE_MUSIC_TABLE;
    395              PROTOCOLO_bufferTmp[1] = 10;
    396              PROTOCOLO_bufferTmp[2] = musica;
    397              PROTOCOLO_bufferTmp[3] = enderecoInicial>>16;
    398              PROTOCOLO_bufferTmp[4] = enderecoInicial>>8;
    399              PROTOCOLO_bufferTmp[5] = enderecoInicial;
    400              PROTOCOLO_bufferTmp[6] = tamanho>>16;
    401              PROTOCOLO_bufferTmp[7] = tamanho>>8;
    402              PROTOCOLO_bufferTmp[8] = tamanho;
    403              PROTOCOLO_bufferTmp[9] = PROTOCOLO_checksum(PROTOCOLO_bufferTmp,9);
    404              
    405              PROTOCOLO_enviaPacote(PROTOCOLO_bufferTmp,10);                      
    406            }        
    407                                                      */
    408          }
   \                     PROTOCOLO_decodeEscreveTabelaMusicas:
   \   00000000   0x4770             BX       LR               ;; return
    409          /***********************************************************************************
    410          *       Descrição       :       Lê os valores da tabela de música do sistema
    411          *       Parametros      :       (unsigned char) música
    412          *       Retorno         :       nenhum
    413          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    414          void PROTOCOLO_decodeLeituraTabelaMusicas(unsigned char musica){
    415            
    416            /*
    417            if(musica>3){
    418              PROTOCOLO_bufferTmp[0] = READ_MUSIC_TABLE | 0x80;
    419              PROTOCOLO_bufferTmp[1] = 4;
    420              PROTOCOLO_bufferTmp[2] = 1;
    421              PROTOCOLO_bufferTmp[3] = PROTOCOLO_checksum(PROTOCOLO_bufferTmp,3);
    422              
    423              PROTOCOLO_enviaPacote(PROTOCOLO_bufferTmp,4);   
    424            }
    425            else{
    426              unsigned int enderecoInicial;
    427              unsigned int tamanho;
    428              
    429              
    430              PARAMETROS_le(ADR_INICIO_BLOCO_MUSICA+musica ,(void*)&enderecoInicial);
    431              PARAMETROS_le(ADR_TAMANHO_BLOCO_MUSICA+musica,(void*)&tamanho);
    432              
    433              enderecoInicial -= AREA_AUDIO;
    434              
    435              PROTOCOLO_bufferTmp[0] = READ_MUSIC_TABLE;
    436              PROTOCOLO_bufferTmp[1] = 10;
    437              PROTOCOLO_bufferTmp[2] = musica;
    438              PROTOCOLO_bufferTmp[3] = enderecoInicial>>16;
    439              PROTOCOLO_bufferTmp[4] = enderecoInicial>>8;
    440              PROTOCOLO_bufferTmp[5] = enderecoInicial;
    441              PROTOCOLO_bufferTmp[6] = tamanho>>16;
    442              PROTOCOLO_bufferTmp[7] = tamanho>>8;
    443              PROTOCOLO_bufferTmp[8] = tamanho;
    444              PROTOCOLO_bufferTmp[9] = PROTOCOLO_checksum(PROTOCOLO_bufferTmp,9);
    445              
    446              PROTOCOLO_enviaPacote(PROTOCOLO_bufferTmp,10);   
    447            }  
    448            */
    449          }
   \                     PROTOCOLO_decodeLeituraTabelaMusicas:
   \   00000000   0x4770             BX       LR               ;; return
    450          /***********************************************************************************
    451          *       Descrição       :       envia data direto
    452          *       Parametros      :       nenhum
    453          *       Retorno         :       nenhum
    454          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    455          void PROTOCOLO_enviaDadosDireto(unsigned char *buffer,unsigned char tamanho){
    456            
    457            /*
    458            for(unsigned char i=0;i<tamanho;i++)
    459              PROTOCOLO_bufferTx[i] = buffer[i];
    460            
    461            PROTOCOLO_bytesParaEnviar = tamanho-1;
    462            PROTOCOLO_bytesEnviados = 1;
    463            U3THR = buffer[0];    
    464            */
    465          }
   \                     PROTOCOLO_enviaDadosDireto:
   \   00000000   0x4770             BX       LR               ;; return
    466          /***********************************************************************************
    467          *       Descrição       :       Verifica se o buffer de transmissão está vazio
    468          *       Parametros      :       nenhum
    469          *       Retorno         :       Tamanho do buffer de transmissão
    470          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    471          unsigned short int PROTOCOLO_bytesNoBufferTx(void){
    472            
    473            return PROTOCOLO_bytesParaEnviar;
   \                     PROTOCOLO_bytesNoBufferTx:
   \   00000000   0x....             LDR.N    R0,??DataTable2_1
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000006   0x4770             BX       LR               ;; return
    474          }
    475          /***********************************************************************************
    476          *       Descrição       :       Decodofica o comando para leitura do tamanho
    477          *                               da listagem de parâmetros
    478          *       Parametros      :       nenhum
    479          *       Retorno         :       nenhum
    480          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    481          void PROTOCOLO_decodifica_tamanho_parametros(void){
    482            
    483            /*
    484              PROTOCOLO_bufferTmp[0] = GET_PARAMETERS_LENGHT;
    485              PROTOCOLO_bufferTmp[1] = 6;
    486              PROTOCOLO_bufferTmp[2] = TAMANHO_PARAMETROS>>8;    
    487              PROTOCOLO_bufferTmp[3] = TAMANHO_PARAMETROS;
    488              PROTOCOLO_bufferTmp[4] = PROTOCOLO_checksum(PROTOCOLO_bufferTmp,4);
    489              PROTOCOLO_enviaPacote(PROTOCOLO_bufferTmp,5);    
    490            */
    491          }
   \                     PROTOCOLO_decodifica_tamanho_parametros:
   \   00000000   0x4770             BX       LR               ;; return
    492          /***********************************************************************************
    493          *       Descrição       :       Decodifica o comando que solocita a informação
    494          *                               sobre um dos parâmetros
    495          *       Parametros      :       (unsigned int) parametro
    496          *       Retorno         :       nenhum
    497          ***********************************************************************************/
    498          extern const sPARAMETROS tabela_parametros[];

   \                                 In section .text, align 2, keep-with-next
    499          void PROTOCOLO_decodifica_info_sobre_parametro(unsigned short int parametro){
    500            
    501            /*
    502             PROTOCOLO_bufferTmp[0] = GET_PARAMETER_INFO;
    503             PROTOCOLO_bufferTmp[1] = parametro;
    504             PROTOCOLO_bufferTmp[2] = tabela_parametros[parametro].length;
    505             
    506             for(unsigned char i=0;i<32;i++)    
    507               PROTOCOLO_bufferTmp[3+i] = tabela_parametros[parametro].nome[i];
    508             
    509             PROTOCOLO_bufferTmp[36] = tabela_parametros[parametro].ext[0];
    510             PROTOCOLO_bufferTmp[37] = tabela_parametros[parametro].ext[1];
    511             PROTOCOLO_bufferTmp[38] = tabela_parametros[parametro].ext[2];
    512             PROTOCOLO_bufferTmp[39] = PROTOCOLO_checksum(PROTOCOLO_bufferTmp,39);
    513             PROTOCOLO_enviaPacote(PROTOCOLO_bufferTmp,40);
    514            */
    515          }
   \                     PROTOCOLO_decodifica_info_sobre_parametro:
   \   00000000   0x4770             BX       LR               ;; return
    516          /***********************************************************************************
    517          *       Descrição       :       Decodifica o comando que solicita a leitura
    518          *                               de um dos parâmetros do sistema
    519          *       Parametros      :       (unsigned short int) parâmetro
    520          8       Retorno         :       nenhum
    521          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    522          void PROTOCOLO_decodifica_leitura_valor_parametro(unsigned short int parametro){
    523            
    524            
    525          }
   \                     PROTOCOLO_decodifica_leitura_valor_parametro:
   \   00000000   0x4770             BX       LR               ;; return
    526          /***********************************************************************************
    527          *       Descrição       :       Decodifica o comando que solicita a escrita
    528          *                               de um dos parâmetros do sistema
    529          *       Parametro       :       (unsigned int) parametro
    530          *                               (unsigned char) tipo
    531          *                               (unsigned char*) dados do parâmetro
    532          *       Retorno         :       nenhum
    533          ***********************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    534          void PROTOCOLO_decodifica_escrita_valor_parametro(unsigned short int parametro,
    535                                                            unsigned char tipo,
    536                                                            unsigned char *valor){
    537                                                      
    538                                                              
    539                                                              
    540                                                              
    541                                                              
    542          }
   \                     PROTOCOLO_decodifica_escrita_valor_parametro:
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x4009C008         DC32     0x4009c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     PROTOCOLO_bytesParaEnviar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     PROTOCOLO_bytesEnviados

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     PROTOCOLO_bufferTx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x4009C000         DC32     0x4009c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x........         DC32     ??ultimoRecebido

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x........         DC32     PROTOCOLO_bytesRecebidos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x........         DC32     PROTOCOLO_bufferRx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x........         DC32     PROTOCOLO_novoPacote

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x4009C014         DC32     0x4009c014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0xE000E280         DC32     0xe000e280
    543          /***********************************************************************************
    544          *       Fim do arquivo
    545          ***********************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   PROTOCOLO_bytesNoBufferTx
       4   PROTOCOLO_checksum
       0   PROTOCOLO_decodeEscreveBloco
       0   PROTOCOLO_decodeEscreveTabelaMusicas
       0   PROTOCOLO_decodeFormataAudioFlash
       0   PROTOCOLO_decodeLeBloco
       0   PROTOCOLO_decodeLeituraTabelaMusicas
       0   PROTOCOLO_decodifica_escrita_valor_parametro
       0   PROTOCOLO_decodifica_info_sobre_parametro
       0   PROTOCOLO_decodifica_leitura_valor_parametro
       0   PROTOCOLO_decodifica_tamanho_parametros
       0   PROTOCOLO_enviaDadosDireto
       8   PROTOCOLO_enviaPacote
       8   PROTOCOLO_ini
         8   -> UART_init
       0   PROTOCOLO_intVect
       8   PROTOCOLO_main
         8   -> PROTOCOLO_ini
         8   -> vTaskDelay
       0   PROTOCOLO_timerTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     128  PROTOCOLO_bufferRx
    1024  PROTOCOLO_bufferTmp
    1024  PROTOCOLO_bufferTx
       1  PROTOCOLO_bytesEnviados
       8  PROTOCOLO_bytesNoBufferTx
       1  PROTOCOLO_bytesParaEnviar
       1  PROTOCOLO_bytesRecebidos
      32  PROTOCOLO_checksum
       2  PROTOCOLO_decodeEscreveBloco
       2  PROTOCOLO_decodeEscreveTabelaMusicas
       2  PROTOCOLO_decodeFormataAudioFlash
       2  PROTOCOLO_decodeLeBloco
       2  PROTOCOLO_decodeLeituraTabelaMusicas
       2  PROTOCOLO_decodifica_escrita_valor_parametro
       2  PROTOCOLO_decodifica_info_sobre_parametro
       2  PROTOCOLO_decodifica_leitura_valor_parametro
       2  PROTOCOLO_decodifica_tamanho_parametros
       2  PROTOCOLO_enviaDadosDireto
     128  PROTOCOLO_enviaPacote
      22  PROTOCOLO_ini
     312  PROTOCOLO_intVect
      14  PROTOCOLO_main
       1  PROTOCOLO_novoPacote
       2  PROTOCOLO_timerTick
       1  U3RBRTHR
       4  _A_CLRPEND0
       4  _A_U3FCR
       1  _A_U3LSR
       1  ultimoRecebido

 
 2 181 bytes in section .bss
    10 bytes in section .noinit (abs)
   582 bytes in section .text
 
   582 bytes of CODE memory
 2 181 bytes of DATA memory (+ 10 bytes shared)

Errors: none
Warnings: none
